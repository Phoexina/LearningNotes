# 1 原xslt复现

> [!note] 
> 重要的参考！
> https://blog.noah.360.net/xalan-j-integer-truncation-reproduce-cve-2022-34169/ 
>

## 1.1 简单理解

常量池数最大为2个字节，0xFFFF，如果超过65,535个常量就会溢出
常量会覆盖后面的数据段
并在最后的数组，也就是这个length定义超长数字，写入后续混乱的数据长度，使其u2 attributes_count时与正常结尾对齐
![](../images/Pasted%20image%2020241225152917.png)

## 1.2 原xslt文件调试

> [!note] 
> 参考中带的原文件
> https://gist.github.com/thanatoskira/07dd6124f7d8197b48bc9e2ce900937f
> 

首先我在win上调试的，所以命令行需要修改
为了不改动偏移量，需要命令行长度不变
![](../images/Pasted%20image%2020241225154327.png)

直接使用会发现结尾count=512怎么都不对
![](../images/Pasted%20image%2020241225153629.png)

看看正常的class结尾
![](../images/Pasted%20image%2020241225153739.png)

可以看到应该把count 从02挪到0001那里，向前偏移7位
```
 00 01 00 01 | 00 00 00*02 | 00 02
*00 01 00 01 | 00 00 00 02 | 00 02
```

于是尝试将后面纯填充区的常量增加7位

成功弹出计算器
![](../images/Pasted%20image%2020241225154218.png)

## 1.3 本不用调试的原文件

实际上这个xlst文件应该是直接能用的，这里不能用是因为
abcde和select字数不一样！
文件名改成6个字母的就好了

本质上是常量池溢出后的部分存在文件名，装混沌数据的数组位数，需要完美的装下后续数据
文件名减少，就会导致装多了，所以可以通过添加字符恢复

# 2 为攻击环境调试xslt

没存图，只能干写了
## 2.1 使用jdk自带xalan框架

参考脚本是在pom引用依赖xalan2.7.2的

jdk自带的xalan也存在对应版本
jdk1.8.0_151是xalan2.7.0
jdk1.8.0_242是xalan2.7.2

不同的xalan版本常量池不一样
测试代码：

```java
import com.sun.org.apache.xalan.internal.xslt.Process;
public class Main {  
    public static void main(String[] args) throws Exception {  
        String xsltTemplate = "abcdf.xslt";  
        Process._main(new String[]{"-XSLTC", "-IN", "source.xml", "-XSL", xsltTemplate, "-XT"});
    }  
}
```

需要注意super_class必须与正常生成class的super_class一致
并不是可以自定义的项

比如pom引用依赖xalan的是：
jdk自带的是：com/sun/org/apache/xalan/internal/xsltc/runtime/AbstractTranslet

## 2.2 使用signature.validate()触发

对于固定版本main的转换，存在一个xslt的通用解
对于固定版本的签名校验操作，也存在一个可以触发的xml里的sig项，在xsl:template中放入可以触发cve的xslt
这里的xslt和main的不是一个，在底层转换器中传入参数有14个不一样，最后生成的class不同

```xml
<root xmlns="http://www.example.com">  
    <data>Hello, World!</data>  
    <Signature xmlns="http://www.w3.org/2000/09/xmldsig#">  
        <SignedInfo>            
        <CanonicalizationMethod Algorithm="http://www.w3.org/2001/10/xml-exc-c14n#"/>  
            <SignatureMethod Algorithm="http://www.w3.org/2000/09/xmldsig#rsa-sha1"/>  
            <Reference URI="">  
                <Transforms>                    
	                <Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature">  
                    <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">  
                        <xsl:template>  
                        </xsl:template>  
                    </xsl:stylesheet>  
	                </Transform>                
	            </Transforms>                
	            <DigestMethod Algorithm="http://www.w3.org/2000/09/xmldsig#sha1"/>  
                <DigestValue>...</DigestValue>  
            </Reference>                
		</SignedInfo>        
		<SignatureValue>...</SignatureValue>  
	    <KeyInfo>
		    <X509Data>
			<X509Certificate>...</X509Certificate>  
	        </X509Data>        
	    </KeyInfo>
	</Signature>
</root>
```

签名校验样例：

```java
public static void signturevalidate(){  
    PublicKey publickey;  
    Document doc;  
    DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();  
    dbf.setNamespaceAware(true);  
    try {
	    //读取doc.xml
        FileInputStream fis = new FileInputStream("poc.xml");  
        doc = dbf.newDocumentBuilder().parse(fis);  
        doc.getDocumentElement().setIdAttribute("ID", true);  

		//随机生成公钥
        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA");  
        keyPairGenerator.initialize(2048);  
        KeyPair keyPair = keyPairGenerator.genKeyPair();  
        publickey = keyPair.getPublic();  

		//提取xml里的sig项
        NodeList nl = doc.getElementsByTagNameNS(XMLSignature.XMLNS, "Signature");  
        Node sigatureNode = nl.item(0);  

		//解析sig项
        XMLSignatureFactory fac = XMLSignatureFactory.getInstance("DOM");  
        DOMValidateContext valContext = new DOMValidateContext(publickey, sigatureNode);  
        XMLSignature signature = fac.unmarshalXMLSignature(valContext);  
  
        //能通过签名的，直接校验触发  
        //signature.validate(valContext);  
  
        //不能通过签名的，通过获取错误信息触发  
        Iterator<?> iterator = signature.getSignedInfo().getReferences().iterator();  
        ((Reference)iterator.next()).validate(valContext);  
          
    } catch (Exception e){  
        e.printStackTrace();  
    }  
}
```

这个转换不会输出class文件，可以通过调试将class字节码导出成文件查看
com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl#newTemplates
断点`byte[][] bytecodes = xsltc.compile(null, input, outputType);`
在newTemplates这里xslt作为参数传入，编译为字节码
可以用`new FileOutputStream("output.class").write(bytecode[3]);` 导出class文件

## 2.3 关键对齐点

常量池从1开始计数，编辑器是从0开始的数组格式
- 常量ExsltStrings类Class_info在0x106，常量index=0x106-1=261
- flag卡在0807，this_class卡在0106，即这个位置的String格式次序是0x701
- 文件结尾处，count为00 01，attributes为 00 01 00 00 00 02 00 02，可通过调整上面的u4 attribute_length控制字符数

至此class基本框架确定，不需要调整偏移量
- method对齐的常量，0的index是utf8的transferOutputSettings，u2 descriptor_index是+1，1的index是utf8的`<init>`
- method1的attriutes1的index是Code

可以检查是否可以使用javap xxx.class看到一个无报错的类，如果大致结构无问题但是javap报错，需要检查一下class的引用是否正常
可能会出现指向的是class的名字string的情况
- Struct Code中调用函数的index是Methodref

## 2.4 通用性总结

从代码的角度：
依赖mvn的xalan和使用jdk的xalan没有本质区别，但类名不一样
signature相比与xalan在转换时会传入不同的参数

从解的角度：
依赖mvn的xalan使用的xlst，使用jdk的xalan使用的xlst，signature的xml中的xlst
是完全不同的
在各自的同Xalan版本中通用

# 3 构造自己的xslt

## 2.1 准备浮点数来精确设置数据

比如参考中记录的浮点数
![](../images/Pasted%20image%2020241225162933.png)
![](../images/Pasted%20image%2020241225163007.png)

可以写一个python进行相互转换

```python
def float_to_hex(num):  
    # 将浮点数转换为二进制格式  
    packed = struct.pack('!d', num)  # 使用大端字节序  
    # 将二进制数据转换为十六进制字符串  
    hex_representation = packed.hex().upper()  # 转换为十六进制并转换为大写  
    return hex_representation  
  
def hex_to_float(hex_string):  
    # 将十六进制字符串转换为字节  
    bytes_data = bytes.fromhex(hex_string)  
    # 将字节转换为浮点数  
    float_number = struct.unpack('!d', bytes_data)[0]  # 使用大端字节序  
    return float_number

num = 0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000109383805324109288191070689135587379  
binary_representation = float_to_hex(num)  
print(binary_representation)  
hex_string = '0007dd9412345678'  # 对应于浮点数 0.00000000000000000011310536823805084float_number = hex_to_float(hex_string)  
print(f"{float_number:.1000f}")

```

浮点数注定是循环不尽的，应该只需要让保留位的float->hex可以与自己想要的一致就可以了

如果是整数就是它的十六进制，但是！！！！！![](../images/Pasted%20image%2020241225183046.png)！！
![](../images/Pasted%20image%2020241225183046.png)

## 2.2 对齐thisclass

![](../images/Pasted%20image%2020241225164023.png)

在正常select.class文件中
this_class指向的#4，在classpy里是从#1开始的，在编辑器里是从0开始的
也就是要指向字符串的下一个，为class_info的常量

![](../images/Pasted%20image%2020241225170254.png)

access_flag需要等于0807，this_class需要指向classinfo的位置
这里的access_flag先按文档写的来
![](../images/Pasted%20image%2020241227093212.png)
也就是说常量池里至少要有0x700以上的字符串

设计把有效常量放入后开始溢出


常量池106也就是#107  = 0x6B
也就是需要让常量池后为 0807 006B 
![](../images/Pasted%20image%2020241226100852.png)

等一下这个也有问题
08 07 00 是一组string但是6B不能作为tag
并且为了接下来能填写方便最好是int或double，不过int需要一定大小才能用

先试试int
08 07 01 03 
emmm只能是偶数
![](../images/Pasted%20image%2020241226102830.png)

题解的偶数是怎么来的呢
可以看到string第一次还是偶数，放入了一个int，后面的string就是奇数了
![](../images/Pasted%20image%2020241226103153.png)

很好那我可以不可以就用偶数捏？算了，01变02需要增加0x100个string
还要挪动一下com.sun.org.apache.xalan.internal.lib.ExsltStrings让它在0x100后

设置成#261 可以对应int
08 07 01 | 03
![](../images/Pasted%20image%2020241226142932.png)

还想试试long，但很遗憾，写了111111111111好像变成了double，并且格式也不太对
int只有4字节，double8字节

此时的xslt文件
![](../images/Pasted%20image%2020241226143406.png)
![](../images/Pasted%20image%2020241226145915.png)
后面的全部都是溢出填充，目的是控制常量池的大小

可以得知 `<x0 x1='x2'` 对于新的x0, x1, x2每个都会放入两个常量utf8和string
第一次使用ceiling会放入10个
对于第二次使用的ceiling，ceiling(1111111)则会放入1个int
![](../images/Pasted%20image%2020241226150905.png)

当前效果，由于放的是int，不知道能不能写下去
![](../images/Pasted%20image%2020241227091253.png)

## 2.3 对齐count为0


一个正常的类现在这里是
![](../images/Pasted%20image%2020241227093829.png)

我们同样需要让superclass等于这个，直接引用常量池原来的这个位置，也就是#6
![](../images/Pasted%20image%2020241227093913.png)

如果按这样下去，会发现，u2 fields_count必然要大于0x100了，显然这很离谱
![](../images/Pasted%20image%2020250103093750.png)

也就是这个常量必然是8位的才可以，所以还是使用double吧
到这里可以看到，原xslt的整个格式框架的关键点其实是不能修改的

## 2.4 其他对齐点展示

因为已知自己写和调试已经没有本质区别了，就不自己写了
直接看一下已经调好的对齐点

这个部分完全由浮点数构成
![](../images/Pasted%20image%2020250108163236.png)


### 2.4.1 使用浮点数对齐method

![](../images/Pasted%20image%2020250108162050.png)
![](../images/Pasted%20image%2020250108162302.png)


### 2.4.2 对齐Code及里面的函数

![](../images/Pasted%20image%2020250108162202.png)

index -> 129的methodref -> 128的NameAndType ->66的`<init>`
![](../images/Pasted%20image%2020250108162603.png)
![](../images/Pasted%20image%2020250108162657.png)

### 2.4.3 对齐混沌数据数组

![](../images/Pasted%20image%2020250108162807.png)
![](../images/Pasted%20image%2020250108162930.png)

也就是对齐尾部，把乱七八糟的数据都收束进去