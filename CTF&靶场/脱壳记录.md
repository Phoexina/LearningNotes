## 0 资料存档

初学参考最佳：
xdbg+scylla通俗易懂，但无exe
https://hello-ctf.com/hc-reverse/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E5%A3%B3/

其他资料：
简单案例，有exe
https://ciphersaw.me/ctf-wiki/reverse/windows/unpack/manually-fix-iat/
视频案例，exe需付费
https://www.bilibili.com/video/BV1us411P7yo?from=search&seid=1267368212914346292&vd_source=dd37d0663cb932686c57f59997c46064&spm_id_from=333.788.videopod.episodes&p=5
tElock壳脱壳，导出表修复？
https://www.52pojie.cn/thread-134646-1-1.html
无exe仅参考
https://www.cnblogs.com/LyShark/p/13731329.html

## 1 ASPACK实战

> [!note] 
>  为了学win10上的堆溢出利用，搜到了一个 https://www.52pojie.cn/thread-1107471-1-1.html
>  有一个aspack壳，用脱壳机没搞明白
>  用xdbg模仿 https://www.52pojie.cn/forum.php?mod=viewthread&tid=1564404&highlight=aspack
>  脱壳是成功了（
>  但堆溢出利用的部分好像没走到shellcode哇（xxx）
>  唉，只能继续研究了

应该叫ESP定律脱壳

直接运行到入口：
![](../images/Pasted%20image%2020250226143903.png)
看到这里就是pushad，也就是马上就可以找到程序，总之直接找到ESP中
![](../images/Pasted%20image%2020250226144044.png)
对这里进行硬件断点，在下面的堆栈最上方选地址 右键>断点>硬件断点，访问>4字节
![](../images/Pasted%20image%2020250226150428.png)

直接运行到esp被修改
![](../images/Pasted%20image%2020250226150504.png)

可以看到下面就是0x401280，也就是OEP，在OEP断点，运行过来
![](../images/Pasted%20image%2020250226150559.png)


打开xdbg里面的scylla发现，先点IAT Autosearch，然后点Get Imports。
这里可能因为我之前调过，所以所有API都找到了。之前我做的时候这里是不全的！有两个函数没找到，而且其中一个是HeapAlloc，不能草率删除，会影响实际运行
可以慢慢运行完后面调用的过程，函数表会补全

![](../images/Pasted%20image%2020250226150704.png)

接下来就可Dump出来，然后再对dump的exe进行Fix Dump

> [!note] 
> 一些思考：
> 如果第一次调用时才让IAT表完成，会不会和动态链接的立即绑定和延迟绑定有关系呢？
> 不过简单搜索了一下，好像windows默认都是立即绑定，而且好像延迟绑定是针对整个dll的（？） 
